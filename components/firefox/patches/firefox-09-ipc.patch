--- a/dom/plugins/ipc/PluginModuleParent.h
+++ b/dom/plugins/ipc/PluginModuleParent.h
@@ -212,7 +212,7 @@ private:
 
     // Implement the module-level functions from NPAPI; these are
     // normally resolved directly from the DSO.
-#ifdef OS_LINUX
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
     NPError NP_Initialize(const NPNetscapeFuncs* npnIface,
                           NPPluginFuncs* nppIface);
 #else
--- a/dom/plugins/ipc/PluginProcessParent.cpp
+++ b/dom/plugins/ipc/PluginProcessParent.cpp
@@ -59,6 +59,9 @@ PluginProcessParent::Launch(int32_t time
         if (base::PROCESS_ARCH_X86_64 & pluginLibArchitectures & containerArchitectures) {
             selectedArchitecture = base::PROCESS_ARCH_X86_64;
         }
+               else if (base::PROCESS_ARCH_SPARC & pluginLibArchitectures & containerArchitectures){
+                       selectedArchitecture = base::PROCESS_ARCH_SPARC;        
+               }
         else if (base::PROCESS_ARCH_I386 & pluginLibArchitectures & containerArchitectures) {
             selectedArchitecture = base::PROCESS_ARCH_I386;
         }
diff --git a/ipc/chromium/src/base/atomicops_internals_x86_gcc.cc b/ipc/chromium/src/base/atomicops_internals_x86_gcc.cc
index 933ca51..b0b3eb1 100644
--- a/ipc/chromium/src/base/atomicops_internals_x86_gcc.cc
+++ b/ipc/chromium/src/base/atomicops_internals_x86_gcc.cc
@@ -19,13 +19,13 @@
 // Inline cpuid instruction.  In PIC compilations, %ebx contains the address
 // of the global offset table.  To avoid breaking such executables, this code
 // must preserve that register's value across cpuid instructions.
-#if defined(__i386__)
+#if defined(__i386__) || defined(__i386)
 #define cpuid(a, b, c, d, inp) \
   asm ("mov %%ebx, %%edi\n"    \
        "cpuid\n"               \
        "xchg %%edi, %%ebx\n"   \
        : "=a" (a), "=D" (b), "=c" (c), "=d" (d) : "a" (inp))
-#elif defined (__x86_64__)
+#elif defined (__x86_64__) || defined(__x86_64)
 #define cpuid(a, b, c, d, inp) \
   asm ("mov %%rbx, %%rdi\n"    \
        "cpuid\n"               \
diff --git a/ipc/chromium/src/base/atomicops_internals_x86_gcc.h b/ipc/chromium/src/base/atomicops_internals_x86_gcc.h
index fda5029..364beee 100644
--- a/ipc/chromium/src/base/atomicops_internals_x86_gcc.h
+++ b/ipc/chromium/src/base/atomicops_internals_x86_gcc.h
@@ -29,18 +29,18 @@ inline Atomic32 NoBarrier_CompareAndSwap
                                          Atomic32 old_value,
                                          Atomic32 new_value) {
   Atomic32 prev;
-  __asm__ __volatile__("lock; cmpxchgl %1,%2"
+  __asm__ __volatile__("lock; cmpxchgl %1,(%2)"
                        : "=a" (prev)
-                       : "q" (new_value), "m" (*ptr), "0" (old_value)
+                       : "q" (new_value), "r" (ptr), "0" (old_value)
                        : "memory");
   return prev;
 }
 
 inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,
                                          Atomic32 new_value) {
-  __asm__ __volatile__("xchgl %1,%0"  // The lock prefix is implicit for xchg.
+  __asm__ __volatile__("xchgl (%1),%0"  // The lock prefix is implicit for xchg.
                        : "=r" (new_value)
-                       : "m" (*ptr), "0" (new_value)
+                       : "r" (ptr), "0" (new_value)
                        : "memory");
   return new_value;  // Now it's the previous value.
 }
@@ -48,8 +48,8 @@ inline Atomic32 NoBarrier_AtomicExchange
 inline Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr,
                                           Atomic32 increment) {
   Atomic32 temp = increment;
-  __asm__ __volatile__("lock; xaddl %0,%1"
-                       : "+r" (temp), "+m" (*ptr)
+  __asm__ __volatile__("lock; xaddl %0,(%1)"
+                       : "+r" (temp), "+r" (ptr)
                        : : "memory");
   // temp now holds the old value of *ptr
   return temp + increment;
@@ -58,8 +58,8 @@ inline Atomic32 NoBarrier_AtomicIncremen
 inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
                                         Atomic32 increment) {
   Atomic32 temp = increment;
-  __asm__ __volatile__("lock; xaddl %0,%1"
-                       : "+r" (temp), "+m" (*ptr)
+  __asm__ __volatile__("lock; xaddl %0,(%1)"
+                       : "+r" (temp), "+r" (ptr)
                        : : "memory");
   // temp now holds the old value of *ptr
   if (AtomicOps_Internalx86CPUFeatures.has_amd_lock_mb_bug) {
@@ -153,18 +153,18 @@ inline Atomic64 NoBarrier_CompareAndSwap
                                          Atomic64 old_value,
                                          Atomic64 new_value) {
   Atomic64 prev;
-  __asm__ __volatile__("lock; cmpxchgq %1,%2"
+  __asm__ __volatile__("lock; cmpxchgq %1,(%2)"
                        : "=a" (prev)
-                       : "q" (new_value), "m" (*ptr), "0" (old_value)
+                       : "q" (new_value), "r" (ptr), "0" (old_value)
                        : "memory");
   return prev;
 }
 
 inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,
                                          Atomic64 new_value) {
-  __asm__ __volatile__("xchgq %1,%0"  // The lock prefix is implicit for xchg.
+  __asm__ __volatile__("xchgq (%1),%0"  // The lock prefix is implicit for xchg.
                        : "=r" (new_value)
-                       : "m" (*ptr), "0" (new_value)
+                       : "r" (ptr), "0" (new_value)
                        : "memory");
   return new_value;  // Now it's the previous value.
 }
@@ -172,8 +172,8 @@ inline Atomic64 NoBarrier_AtomicExchange
 inline Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr,
                                           Atomic64 increment) {
   Atomic64 temp = increment;
-  __asm__ __volatile__("lock; xaddq %0,%1"
-                       : "+r" (temp), "+m" (*ptr)
+  __asm__ __volatile__("lock; xaddq %0,(%1)"
+                       : "+r" (temp), "+r" (ptr)
                        : : "memory");
   // temp now contains the previous value of *ptr
   return temp + increment;
@@ -182,8 +182,8 @@ inline Atomic64 NoBarrier_AtomicIncremen
 inline Atomic64 Barrier_AtomicIncrement(volatile Atomic64* ptr,
                                         Atomic64 increment) {
   Atomic64 temp = increment;
-  __asm__ __volatile__("lock; xaddq %0,%1"
-                       : "+r" (temp), "+m" (*ptr)
+  __asm__ __volatile__("lock; xaddq %0,(%1)"
+                       : "+r" (temp), "+r" (ptr)
                        : : "memory");
   // temp now contains the previous value of *ptr
   if (AtomicOps_Internalx86CPUFeatures.has_amd_lock_mb_bug) {
diff --git a/ipc/chromium/src/base/base_paths_linux.cc b/ipc/chromium/src/base/base_paths_linux.cc
index b235f6b..865c348 100644
--- a/ipc/chromium/src/base/base_paths_linux.cc
+++ b/ipc/chromium/src/base/base_paths_linux.cc
@@ -21,11 +21,19 @@ bool PathProviderLinux(int key, FilePath
     case base::FILE_EXE:
     case base::FILE_MODULE: { // TODO(evanm): is this correct?
       char bin_dir[PATH_MAX + 1];
+#ifdef OS_SOLARIS
+         if (!(realpath(getexecname(), bin_dir) && bin_dir[0] != '[')){
+               NOTREACHED() << "Unable to get exec name.";
+               return false;
+         }
+         int bin_dir_size = strlen(bin_dir);
+#else
       int bin_dir_size = readlink("/proc/self/exe", bin_dir, PATH_MAX);
       if (bin_dir_size < 0 || bin_dir_size > PATH_MAX) {
         NOTREACHED() << "Unable to resolve /proc/self/exe.";
         return false;
       }
+#endif
       bin_dir[bin_dir_size] = 0;
       *result = FilePath(bin_dir);
       return true;
diff --git a/ipc/chromium/src/base/eintr_wrapper.h b/ipc/chromium/src/base/eintr_wrapper.h
index a3fb1e4..fa44e05 100644
--- a/ipc/chromium/src/base/eintr_wrapper.h
+++ b/ipc/chromium/src/base/eintr_wrapper.h
@@ -16,6 +16,7 @@
 
 #include <errno.h>
 
+#ifndef COMPILER_SUNPRO
 #define HANDLE_EINTR(x) ({ \
   typeof(x) __eintr_result__; \
   do { \
@@ -23,6 +24,15 @@
   } while (__eintr_result__ == -1 && errno == EINTR); \
   __eintr_result__;\
 })
+#else
+#define HANDLE_EINTR(x) ({ \
+  ssize_t __eintr_result__; \
+  do { \
+    __eintr_result__ = x; \
+  } while (__eintr_result__ == -1 && errno == EINTR); \
+  __eintr_result__;\
+})
+#endif
 
 #else
 
diff --git a/ipc/chromium/src/base/file_version_info.h b/ipc/chromium/src/base/file_version_info.h
index f38d23f..065e9ac 100644
--- a/ipc/chromium/src/base/file_version_info.h
+++ b/ipc/chromium/src/base/file_version_info.h
@@ -86,7 +86,7 @@ class FileVersionInfo {
   explicit FileVersionInfo(NSBundle *bundle);
 
   NSBundle *bundle_;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
   FileVersionInfo();
 #endif
 
diff --git a/ipc/chromium/src/base/float_util.h b/ipc/chromium/src/base/float_util.h
index 5909995..905080b 100644
--- a/ipc/chromium/src/base/float_util.h
+++ b/ipc/chromium/src/base/float_util.h
@@ -8,6 +8,9 @@
 #include "build/build_config.h"
 
 #include <float.h>
+#ifdef OS_SOLARIS
+#include <ieeefp.h>
+#endif
 #include <math.h>
 
 namespace base {
diff --git a/ipc/chromium/src/base/gfx/native_widget_types.h b/ipc/chromium/src/base/gfx/native_widget_types.h
index d43db5c..2f4ab87 100644
--- a/ipc/chromium/src/base/gfx/native_widget_types.h
+++ b/ipc/chromium/src/base/gfx/native_widget_types.h
@@ -46,7 +46,7 @@ class NSView;
 class NSWindow;
 class NSTextField;
 #endif  // __OBJC__
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 typedef struct _GtkWidget GtkWidget;
 typedef struct _GtkWindow GtkWindow;
 typedef struct _cairo_surface cairo_surface_t;
@@ -64,7 +64,7 @@ typedef NSView* NativeView;
 typedef NSWindow* NativeWindow;
 typedef NSTextField* NativeEditView;
 typedef CGContext* NativeDrawingContext;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 typedef GtkWidget* NativeView;
 typedef GtkWindow* NativeWindow;
 typedef GtkWidget* NativeEditView;
@@ -86,7 +86,7 @@ typedef intptr_t NativeViewId;
 static inline NativeView NativeViewFromId(NativeViewId id) {
   return reinterpret_cast<NativeView>(id);
 }
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 // A NativeView on Linux is a GtkWidget*. However, we can't go directly from an
 // X window ID to a GtkWidget. Thus, functions which handle NativeViewIds from
 // the renderer have to use Xlib. This is fine since these functions are
@@ -94,7 +94,7 @@ static inline NativeView NativeViewFromI
 
 #define NativeViewFromId(x) NATIVE_VIEW_FROM_ID_NOT_AVAILIBLE_ON_LINUX
 
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_SOLARIS)
 
 // Convert a NativeView to a NativeViewId. See the comments above
 // NativeViewFromId.
@@ -102,10 +102,10 @@ static inline NativeView NativeViewFromI
 static inline NativeViewId IdFromNativeView(NativeView view) {
   return reinterpret_cast<NativeViewId>(view);
 }
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 // Not inlined because it involves pulling too many headers.
 NativeViewId IdFromNativeView(NativeView view);
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_SOLARIS)
 
 }  // namespace gfx
 
diff --git a/ipc/chromium/src/base/idle_timer.cc b/ipc/chromium/src/base/idle_timer.cc
index de980f1..34ee461 100644
--- a/ipc/chromium/src/base/idle_timer.cc
+++ b/ipc/chromium/src/base/idle_timer.cc
@@ -7,13 +7,13 @@
 // We may not want to port idle_timer to Linux, but we have implemented it
 // anyway.  Define this to 1 to enable the Linux idle timer and then add the
 // libs that need to be linked (Xss).
-#define ENABLE_XSS_SUPPORT 0
+#define ENABLE_XSS_SUPPORT 1
 
 #if defined(OS_MACOSX)
 #include <ApplicationServices/ApplicationServices.h>
 #endif
 
-#if defined(OS_LINUX) && ENABLE_XSS_SUPPORT
+#if defined(OS_LINUX) || defined(OS_SOLARIS) && ENABLE_XSS_SUPPORT
 // We may not want to port idle_timer to Linux, but we have implemented it
 // anyway.  Remove the 0 above if we want it.
 #include <gdk/gdkx.h>
@@ -54,7 +54,7 @@ bool OSIdleTimeSource(int32_t *milliseco
           kCGAnyInputEventType) * 1000.0;
   return true;
 }
-#elif defined(OS_LINUX) && ENABLE_XSS_SUPPORT
+#elif defined(OS_LINUX) || defined(OS_SOLARIS) && ENABLE_XSS_SUPPORT
 class IdleState {
  public:
   IdleState() {
diff --git a/ipc/chromium/src/base/native_library.h b/ipc/chromium/src/base/native_library.h
index ce85c23..81d54a1 100644
--- a/ipc/chromium/src/base/native_library.h
+++ b/ipc/chromium/src/base/native_library.h
@@ -26,7 +26,7 @@ typedef char* NativeLibraryFunctionNameT
 #elif defined(OS_MACOSX)
 typedef CFBundleRef NativeLibrary;
 typedef CFStringRef NativeLibraryFunctionNameType;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 typedef void* NativeLibrary;
 typedef const char* NativeLibraryFunctionNameType;
 #endif  // OS_*
diff --git a/ipc/chromium/src/base/observer_list.h b/ipc/chromium/src/base/observer_list.h
index f67df14..3f26f93 100644
--- a/ipc/chromium/src/base/observer_list.h
+++ b/ipc/chromium/src/base/observer_list.h
@@ -88,7 +88,7 @@ class ObserverList {
 
   // Add an observer to the list.
   void AddObserver(ObserverType* obs) {
-    DCHECK(find(observers_.begin(), observers_.end(), obs) == observers_.end())
+    DCHECK(std::find(observers_.begin(), observers_.end(), obs) == observers_.end())
         << "Observers can only be added once!";
     observers_.push_back(obs);
   }
diff --git a/ipc/chromium/src/base/path_service.cc b/ipc/chromium/src/base/path_service.cc
index f625c98..3228de7 100644
--- a/ipc/chromium/src/base/path_service.cc
+++ b/ipc/chromium/src/base/path_service.cc
@@ -24,7 +24,7 @@ namespace base {
   bool PathProviderWin(int key, FilePath* result);
 #elif defined(OS_MACOSX)
   bool PathProviderMac(int key, FilePath* result);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
   bool PathProviderLinux(int key, FilePath* result);
 #endif
 }
@@ -80,7 +80,7 @@ static Provider base_provider_mac = {
 };
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
 static Provider base_provider_linux = {
   base::PathProviderLinux,
   &base_provider,
@@ -92,6 +92,17 @@ static Provider base_provider_linux = {
 };
 #endif
 
+#if 0//defined(OS_SOLARIS) 
+static Provider base_provider_posix = {
+  base::PathProviderPosix,
+  &base_provider,
+#ifndef NDEBUG
+  0,
+  0,
+#endif
+  true
+};
+#endif
 
 struct PathData {
   Lock      lock;
@@ -104,7 +115,7 @@ struct PathData {
     providers = &base_provider_win;
 #elif defined(OS_MACOSX)
     providers = &base_provider_mac;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
     providers = &base_provider_linux;
 #endif
   }
@@ -206,6 +217,24 @@ bool PathService::IsOverridden(int key)
   return path_data->overrides.find(key) != path_data->overrides.end();
 }
 
+#ifdef OS_SOLARIS
+bool PathService::Override(int key, const FilePath& path) {
+  PathData* path_data = GetPathData();
+  DCHECK(path_data);
+  DCHECK(key > base::DIR_CURRENT) << "invalid path key";
+  
+  FilePath file_path = path;
+ 
+  // make sure the directory exists:
+  if (!file_util::CreateDirectory(file_path))
+    return false;
+
+  AutoLock scoped_lock(path_data->lock);
+  path_data->cache[key] = file_path;
+  path_data->overrides.insert(key);
+  return true;
+}
+#else
 bool PathService::Override(int key, const std::wstring& path) {
   PathData* path_data = GetPathData();
   DCHECK(path_data);
@@ -231,8 +260,13 @@ bool PathService::Override(int key, cons
   path_data->overrides.insert(key);
   return true;
 }
+#endif
 
+#ifdef OS_SOLARIS
+bool PathService::SetCurrentDirectory(const FilePath& current_directory) {
+#else
 bool PathService::SetCurrentDirectory(const std::wstring& current_directory) {
+#endif
   return file_util::SetCurrentDirectory(current_directory);
 }
 
diff --git a/ipc/chromium/src/base/path_service.h b/ipc/chromium/src/base/path_service.h
index 86d6a4a..41a7d56 100644
--- a/ipc/chromium/src/base/path_service.h
+++ b/ipc/chromium/src/base/path_service.h
@@ -48,14 +48,20 @@ class PathService {
   //
   // WARNING: Consumers of PathService::Get may expect paths to be constant
   // over the lifetime of the app, so this method should be used with caution.
+#ifdef OS_SOLARIS
+  static bool Override(int key, const FilePath& path);
+#else
   static bool Override(int key, const std::wstring& path);
-
+#endif
   // Return whether a path was overridden.
   static bool IsOverridden(int key);
 
   // Sets the current directory.
+#ifdef OS_SOLARIS
+  static bool SetCurrentDirectory(const FilePath& current_directory);
+#else
   static bool SetCurrentDirectory(const std::wstring& current_directory);
-
+#endif
   // To extend the set of supported keys, you can register a path provider,
   // which is just a function mirroring PathService::Get.  The ProviderFunc
   // returns false if it cannot provide a non-empty path for the given key.
diff --git a/ipc/chromium/src/base/shared_memory_posix.cc b/ipc/chromium/src/base/shared_memory_posix.cc
index 3a26550..006672e 100644
--- a/ipc/chromium/src/base/shared_memory_posix.cc
+++ b/ipc/chromium/src/base/shared_memory_posix.cc
@@ -130,9 +130,15 @@ bool SharedMemory::FilenameForMemoryName
   if (file_util::GetShmemTempDir(&temp_dir) == false)
     return false;
 
+#ifndef OS_SOLARIS
   mem_filename = UTF8ToWide(temp_dir.value());
   file_util::AppendToPath(&mem_filename, L"com.google.chrome.shmem." + memname);
   *filename = mem_filename;
+#else
+  *filename = (temp_dir.Append("com.google.chrome.shmem." + 
+                                                               WideToUTF8(memname))).ToWStringHack();
+#endif
+  
   return true;
 }
 
@@ -236,7 +242,7 @@ bool SharedMemory::Unmap() {
   if (memory_ == NULL)
     return false;
 
-  munmap(memory_, max_size_);
+  munmap((caddr_t)memory_, max_size_);
   memory_ = NULL;
   max_size_ = 0;
   return true;

diff --git a/ipc/chromium/src/base/stack_container.h b/ipc/chromium/src/base/stack_container.h
index 1b325b1..379a614 100644
--- a/ipc/chromium/src/base/stack_container.h
+++ b/ipc/chromium/src/base/stack_container.h
@@ -96,8 +96,13 @@ class StackAllocator : public std::alloc
   // and the size requested fits. Otherwise, fall through to the standard
   // allocator.
   pointer allocate(size_type n, void* hint = 0) {
+#ifdef COMPILER_SUNPRO
+       if (source_ != NULL && !source_->used_stack_buffer_
+               && (n/sizeof(T)) <= stack_capacity) { 
+#else
     if (source_ != NULL && !source_->used_stack_buffer_
         && n <= stack_capacity) {
+#endif
       source_->used_stack_buffer_ = true;
       return source_->stack_buffer();
     } else {
diff --git a/ipc/chromium/src/base/message_pump_glib.cc b/ipc/chromium/src/base/message_pump_glib.cc
index 630c2f9..980bccd 100644
--- a/ipc/chromium/src/base/message_pump_glib.cc
+++ b/ipc/chromium/src/base/message_pump_glib.cc
@@ -131,6 +132,12 @@
   // Create our wakeup pipe, which is used to flag when work was scheduled.
   int fds[2];
   CHECK(pipe(fds) == 0);
+
+  int flags = fcntl(fds[0], F_GETFL, 0);
+  if (flags == -1)
+    flags = 0;
+  fcntl(fds[0], F_SETFL, flags | O_NDELAY);
+
   wakeup_pipe_read_  = fds[0];
   wakeup_pipe_write_ = fds[1];
   wakeup_gpollfd_->fd = wakeup_pipe_read_;
@@ -237,10 +244,9 @@
   // are only signaled when the queue went from empty to non-empty.  The glib
   // poll will tell us whether there was data, so this read shouldn't block.
   if (wakeup_gpollfd_->revents & G_IO_IN) {
-    char msg;
-    if (HANDLE_EINTR(read(wakeup_pipe_read_, &msg, 1)) != 1 || msg != '!') {
-      NOTREACHED() << "Error reading from the wakeup pipe.";
-    }
+    char buf[32];
+    while (HANDLE_EINTR(read(wakeup_pipe_read_, &buf, 32)));
+
     // Since we ate the message, we need to record that we have more work,
     // because HandleCheck() may be called without HandleDispatch being called
     // afterwards.
@@ -304,6 +309,10 @@ void MessagePumpForUI::ScheduleWork() {
   // variables as we would then need locks all over.  This ensures that if
   // we are sleeping in a poll that we will wake up.
   char msg = '!';
+  char buf[32];
+
+  while (HANDLE_EINTR(read(wakeup_pipe_read_, &buf, 32)));
+
   if (HANDLE_EINTR(write(wakeup_pipe_write_, &msg, 1)) != 1) {
     NOTREACHED() << "Could not write to the UI message loop wakeup pipe!";
   }
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -2486,7 +2486,7 @@
        LIBS="-lCrun -lCstd -lc $LIBS"
        AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
        CFLAGS="$CFLAGS -xlibmieee -xstrconst -xbuiltin=%all -D__FUNCTION__=__func__"
-       CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%all -features=tmplife,tmplrefstatic,extensions,no%except -norunpath -D__FUNCTION__=__func__ -template=no%extdef"
+       CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%all -features=tmplife,tmplrefstatic,extensions,no%except -norunpath -D__FUNCTION__=__func__ -template=no%extdef -D_XOPEN_SOURCE=500 -D__EXTENSIONS__"
        LDFLAGS="-xildoff $LDFLAGS"
        if test -z "$CROSS_COMPILE" -a -f /usr/lib/ld/map.noexstk; then
            _SAVE_LDFLAGS=$LDFLAGS
diff --git a/js/src/configure.in b/js/src/configure.in
--- a/js/src/configure.in
+++ b/js/src/configure.in
@@ -2332,7 +2332,7 @@
        LIBS="-lCrun -lCstd -lc $LIBS"
        AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
        CFLAGS="$CFLAGS -xlibmieee -xstrconst -xbuiltin=%all -D__FUNCTION__=__func__"
-       CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%all -features=tmplife,tmplrefstatic,extensions,no%except -norunpath -D__FUNCTION__=__func__ -template=no%extdef"
+       CXXFLAGS="$CXXFLAGS -xlibmieee -xbuiltin=%all -features=tmplife,tmplrefstatic,extensions,no%except -norunpath -D__FUNCTION__=__func__ -template=no%extdef -D_XOPEN_SOURCE=500 -D__EXTENSIONS__"
        LDFLAGS="-xildoff $LDFLAGS"
        if test -z "$CROSS_COMPILE" -a -f /usr/lib/ld/map.noexstk; then
            _SAVE_LDFLAGS=$LDFLAGS
diff --git a/ipc/chromium/chromium-config.mk b/ipc/chromium/chromium-config.mk
--- a/ipc/chromium/chromium-config.mk
+++ b/ipc/chromium/chromium-config.mk
@@ -106,6 +106,21 @@
 
 else # } {
 
+ifeq ($(OS_ARCH),SunOS) # {
+
+OS_SOLARIS = 1
+OS_POSIX = 1
+
+DEFINES += \
+  -DOS_SOLARIS=1 \
+  -DOS_POSIX=1 \
+  $(NULL)
+
+# NB: to stop gcc warnings about exporting template instantiation
+OS_CXXFLAGS := $(filter-out -pedantic,$(OS_CXXFLAGS))
+
+else # } {
+
 OS_LINUX = 1
 DEFINES += \
   -DOS_LINUX=1 \
@@ -120,4 +135,5 @@
 endif # }
 endif # }
 endif # }
+endif # }
 
diff --git a/ipc/ipdl/test/cxx/Makefile.in b/ipc/ipdl/test/cxx/Makefile.in
index c244534..ceca18a 100644
--- a/ipc/ipdl/test/cxx/Makefile.in
+++ b/ipc/ipdl/test/cxx/Makefile.in
@@ -63,6 +63,10 @@
 IPDLTESTS += TestSysVShmem
 endif
 
+ifeq ($(OS_ARCH),SunOS)
+IPDLTESTS += TestSysVShmem
+endif
+
 EXTRA_PROTOCOLS = \
   TestBridgeSub \
   $(NULL)
diff -r 425835f6a9e2 ipc/glue/GeckoChildProcessHost.cpp
--- a/ipc/glue/GeckoChildProcessHost.cpp	Mon Jan 21 13:30:46 2013 -0800
+++ b/ipc/glue/GeckoChildProcessHost.cpp	Tue Jan 22 20:04:31 2013 +0800
@@ -494,12 +494,15 @@
   // and passing wstrings from one config to the other is unsafe.  So
   // we split the logic here.
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
-  base::environment_map newEnvVars;
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD) || defined(OS_SOLARIS)
   ChildPrivileges privs = mPrivileges;
   if (privs == base::PRIVILEGES_DEFAULT) {
     privs = DefaultChildPrivileges();
   }
+#endif
+
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
+  base::environment_map newEnvVars;
   // XPCOM may not be initialized in some subprocesses.  We don't want
   // to initialize XPCOM just for the directory service, especially
   // since LD_LIBRARY_PATH is already set correctly in subprocesses
@@ -636,7 +639,7 @@
   childArgv.push_back(pidstring);
 
 #if defined(MOZ_CRASHREPORTER)
-#  if defined(OS_LINUX) || defined(OS_BSD)
+#  if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
   int childCrashFd, childCrashRemapFd;
   if (!CrashReporter::CreateNotificationPipeForChild(
         &childCrashFd, &childCrashRemapFd))
@@ -652,7 +655,7 @@
   }
 #  elif defined(MOZ_WIDGET_COCOA)
   childArgv.push_back(CrashReporter::GetChildNotificationPipe());
-#  endif  // OS_LINUX
+#  endif  // OS_LINUX || defined(OS_SOLARIS)
 #endif
 
 #ifdef MOZ_WIDGET_COCOA
@@ -675,6 +678,8 @@
   base::LaunchApp(childArgv, mFileMap,
 #if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
                   newEnvVars, privs,
+#elif defined(OS_SOLARIS)
+                  base::environment_map(), privs,
 #endif
                   false, &process, arch);
 
diff --git a/modules/libjar/nsZipArchive.cpp b/modules/libjar/nsZipArchive.cpp
--- a/modules/libjar/nsZipArchive.cpp
+++ b/modules/libjar/nsZipArchive.cpp
@@ -591,7 +592,7 @@
     uint32_t readaheadLength = xtolong(startp);
     if (readaheadLength) {
 #if defined(XP_UNIX)
-      madvise(const_cast<uint8_t*>(startp), readaheadLength, MADV_WILLNEED);
+      posix_madvise(const_cast<uint8_t*>(startp), readaheadLength, MADV_WILLNEED);
 #elif defined(XP_WIN)
       if (aFd) {
         HANDLE hFile = (HANDLE) PR_FileDesc2NativeHandle(aFd);
diff --git a/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h b/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h
new file mode 100644
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h
@@ -0,0 +1,455 @@
+/* event2/event-config.h
+ *
+ * This file was generated by autoconf when libevent was built, and post-
+ * processed by Libevent so that its macros would have a uniform prefix.
+ *
+ * DO NOT EDIT THIS FILE.
+ *
+ * Do not rely on macros in this file existing in later versions.
+ */
+
+#ifndef _EVENT2_EVENT_CONFIG_H_
+#define _EVENT2_EVENT_CONFIG_H_
+
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if libevent should build without support for a debug mode */
+/* #undef _EVENT_DISABLE_DEBUG_MODE */
+
+/* Define if libevent should not allow replacing the mm functions */
+/* #undef _EVENT_DISABLE_MM_REPLACEMENT */
+
+/* Define if libevent should not be compiled with thread support */
+/* #undef _EVENT_DISABLE_THREAD_SUPPORT */
+
+/* Define to 1 if you have the `arc4random' function. */
+/* #undef _EVENT_HAVE_ARC4RANDOM */
+
+/* Define to 1 if you have the `arc4random_buf' function. */
+/* #undef _EVENT_HAVE_ARC4RANDOM_BUF */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define _EVENT_HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define _EVENT_HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 if you have the declaration of `CTL_KERN', and to 0 if you
+   don't. */
+/* #undef _EVENT_HAVE_DECL_CTL_KERN */
+
+/* Define to 1 if you have the declaration of `KERN_ARND', and to 0 if you
+   don't. */
+/* #undef _EVENT_HAVE_DECL_KERN_ARND */
+
+/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
+   don't. */
+/* #undef _EVENT_HAVE_DECL_KERN_RANDOM */
+
+/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
+   don't. */
+#define _EVENT_HAVE_DECL_RANDOM_UUID 1
+
+/* Define if /dev/poll is available */
+#define _EVENT_HAVE_DEVPOLL 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define _EVENT_HAVE_DLFCN_H 1
+
+/* Define if your system supports the epoll system calls */
+/* #undef _EVENT_HAVE_EPOLL */
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+/* #undef _EVENT_HAVE_EPOLL_CTL */
+
+/* Define to 1 if you have the `eventfd' function. */
+/* #undef _EVENT_HAVE_EVENTFD */
+
+/* Define if your system supports event ports */
+#define _EVENT_HAVE_EVENT_PORTS 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define _EVENT_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define _EVENT_HAVE_FCNTL_H 1
+
+/* Define to 1 if the system has the type `fd_mask'. */
+#define _EVENT_HAVE_FD_MASK 1
+
+/* Do we have getaddrinfo()? */
+#define _EVENT_HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getegid' function. */
+#define _EVENT_HAVE_GETEGID 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define _EVENT_HAVE_GETEUID 1
+
+/* Define this if you have any gethostbyname_r() */
+/* #undef _EVENT_HAVE_GETHOSTBYNAME_R */
+
+/* Define this if gethostbyname_r takes 3 arguments */
+/* #undef _EVENT_HAVE_GETHOSTBYNAME_R_3_ARG */
+
+/* Define this if gethostbyname_r takes 5 arguments */
+/* #undef _EVENT_HAVE_GETHOSTBYNAME_R_5_ARG */
+
+/* Define this if gethostbyname_r takes 6 arguments */
+/* #undef _EVENT_HAVE_GETHOSTBYNAME_R_6_ARG */
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define _EVENT_HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `getprotobynumber' function. */
+#define _EVENT_HAVE_GETPROTOBYNUMBER 1
+
+/* Define to 1 if you have the `getservbyname' function. */
+/* #undef _EVENT_HAVE_GETSERVBYNAME */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define _EVENT_HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_aton' function. */
+#define _EVENT_HAVE_INET_ATON 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define _EVENT_HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+#define _EVENT_HAVE_INET_PTON 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define _EVENT_HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `issetugid' function. */
+#define _EVENT_HAVE_ISSETUGID 1
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef _EVENT_HAVE_KQUEUE */
+
+/* Define if the system has zlib */
+#define _EVENT_HAVE_LIBZ 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define _EVENT_HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mmap' function. */
+#define _EVENT_HAVE_MMAP 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define _EVENT_HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef _EVENT_HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define _EVENT_HAVE_NETINET_IN_H 1
+
+/* Define if the system has openssl */
+#define _EVENT_HAVE_OPENSSL 1
+
+/* Define to 1 if you have the <openssl/bio.h> header file. */
+#define _EVENT_HAVE_OPENSSL_BIO_H 1
+
+/* Define to 1 if you have the `pipe' function. */
+#define _EVENT_HAVE_PIPE 1
+
+/* Define to 1 if you have the `poll' function. */
+#define _EVENT_HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define _EVENT_HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+#define _EVENT_HAVE_PORT_CREATE 1
+
+/* Define to 1 if you have the <port.h> header file. */
+#define _EVENT_HAVE_PORT_H 1
+
+/* Define if you have POSIX threads libraries and header files. */
+/* #undef _EVENT_HAVE_PTHREAD */
+
+/* Define if we have pthreads on this system */
+#define _EVENT_HAVE_PTHREADS 1
+
+/* Define to 1 if you have the `putenv' function. */
+#define _EVENT_HAVE_PUTENV 1
+
+/* Define to 1 if the system has the type `sa_family_t'. */
+#define _EVENT_HAVE_SA_FAMILY_T 1
+
+/* Define to 1 if you have the `select' function. */
+#define _EVENT_HAVE_SELECT 1
+
+/* Define to 1 if you have the `sendfile' function. */
+#define _EVENT_HAVE_SENDFILE 1
+
+/* Define to 1 if you have the `setenv' function. */
+#define _EVENT_HAVE_SETENV 1
+
+/* Define if F_SETFD is defined in <fcntl.h> */
+#define _EVENT_HAVE_SETFD 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define _EVENT_HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `signal' function. */
+#define _EVENT_HAVE_SIGNAL 1
+
+/* Define to 1 if you have the `splice' function. */
+#define _EVENT_HAVE_SPLICE 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define _EVENT_HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define _EVENT_HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define _EVENT_HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define _EVENT_HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define _EVENT_HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define _EVENT_HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+#define _EVENT_HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define _EVENT_HAVE_STRSEP 1
+
+/* Define to 1 if you have the `strtok_r' function. */
+#define _EVENT_HAVE_STRTOK_R 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define _EVENT_HAVE_STRTOLL 1
+
+/* Define to 1 if the system has the type `struct addrinfo'. */
+#define _EVENT_HAVE_STRUCT_ADDRINFO 1
+
+/* Define to 1 if the system has the type `struct in6_addr'. */
+#define _EVENT_HAVE_STRUCT_IN6_ADDR 1
+
+/* Define to 1 if `s6_addr16' is a member of `struct in6_addr'. */
+/* #undef _EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR16 */
+
+/* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
+/* #undef _EVENT_HAVE_STRUCT_IN6_ADDR_S6_ADDR32 */
+
+/* Define to 1 if the system has the type `struct sockaddr_in6'. */
+#define _EVENT_HAVE_STRUCT_SOCKADDR_IN6 1
+
+/* Define to 1 if `sin6_len' is a member of `struct sockaddr_in6'. */
+/* #undef _EVENT_HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN */
+
+/* Define to 1 if `sin_len' is a member of `struct sockaddr_in'. */
+/* #undef _EVENT_HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+#define _EVENT_HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */
+#define _EVENT_HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
+
+/* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
+/* #undef _EVENT_HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
+
+/* Define to 1 if you have the `sysctl' function. */
+/* #undef _EVENT_HAVE_SYSCTL */
+
+/* Define to 1 if you have the <sys/devpoll.h> header file. */
+#define _EVENT_HAVE_SYS_DEVPOLL_H 1
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+/* #undef _EVENT_HAVE_SYS_EPOLL_H 1 */
+
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+/* #define _EVENT_HAVE_SYS_EVENTFD_H 1 */
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef _EVENT_HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define _EVENT_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define _EVENT_HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define _EVENT_HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#define _EVENT_HAVE_SYS_QUEUE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define _EVENT_HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/sendfile.h> header file. */
+#define _EVENT_HAVE_SYS_SENDFILE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define _EVENT_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define _EVENT_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+/* #undef _EVENT_HAVE_SYS_SYSCTL_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define _EVENT_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define _EVENT_HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define _EVENT_HAVE_SYS_UIO_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define _EVENT_HAVE_SYS_WAIT_H 1
+
+/* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
+#define _EVENT_HAVE_TAILQFOREACH 1
+
+/* Define if timeradd is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERADD 1
+
+/* Define if timerclear is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCLEAR 1
+
+/* Define if timercmp is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERCMP 1
+
+/* Define if timerisset is defined in <sys/time.h> */
+#define _EVENT_HAVE_TIMERISSET 1
+
+/* Define to 1 if the system has the type `uint16_t'. */
+#define _EVENT_HAVE_UINT16_T 1
+
+/* Define to 1 if the system has the type `uint32_t'. */
+#define _EVENT_HAVE_UINT32_T 1
+
+/* Define to 1 if the system has the type `uint64_t'. */
+#define _EVENT_HAVE_UINT64_T 1
+
+/* Define to 1 if the system has the type `uint8_t'. */
+#define _EVENT_HAVE_UINT8_T 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define _EVENT_HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the `umask' function. */
+#define _EVENT_HAVE_UMASK 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define _EVENT_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define _EVENT_HAVE_UNSETENV 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define _EVENT_HAVE_VASPRINTF 1
+
+/* Define if kqueue works correctly with pipes */
+/* #undef _EVENT_HAVE_WORKING_KQUEUE */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define _EVENT_HAVE_ZLIB_H 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define _EVENT_LT_OBJDIR ".libs/"
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef _EVENT_NO_MINUS_C_MINUS_O */
+
+/* Numeric representation of the version */
+#define _EVENT_NUMERIC_VERSION 0x02001500
+
+/* Name of package */
+#define _EVENT_PACKAGE "libevent"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define _EVENT_PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define _EVENT_PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define _EVENT_PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define _EVENT_PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define _EVENT_PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define _EVENT_PACKAGE_VERSION ""
+
+/* Define to necessary symbol if this constant uses a non-standard name on
+   your system. */
+/* #undef _EVENT_PTHREAD_CREATE_JOINABLE */
+
+/* The size of `int', as computed by sizeof. */
+#define _EVENT_SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG 4
+
+/* The size of `long long', as computed by sizeof. */
+#define _EVENT_SIZEOF_LONG_LONG 8
+
+/* The size of `pthread_t', as computed by sizeof. */
+#define _EVENT_SIZEOF_PTHREAD_T 4
+
+/* The size of `short', as computed by sizeof. */
+#define _EVENT_SIZEOF_SHORT 2
+
+/* The size of `size_t', as computed by sizeof. */
+#define _EVENT_SIZEOF_SIZE_T 4
+
+/* The size of `void *', as computed by sizeof. */
+#define _EVENT_SIZEOF_VOID_P 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define _EVENT_STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define _EVENT_TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define _EVENT_VERSION "2.0.21-stable"
+
+/* Define to appropriate substitue if compiler doesnt have __func__ */
+/* #undef _EVENT___func__ */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef _EVENT_const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef _EVENT___cplusplus
+/* #undef _EVENT_inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef _EVENT_pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef _EVENT_size_t */
+
+/* Define to unsigned int if you dont have it */
+/* #undef _EVENT_socklen_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef _EVENT_ssize_t */
+
+#endif /* event2/event-config.h */
diff --git a/mfbt/Poison.cpp b/mfbt/Poison.cpp
--- a/mfbt/Poison.cpp
+++ b/mfbt/Poison.cpp
@@ -125,7 +126,7 @@
 static bool
 ProbeRegion(uintptr_t region, uintptr_t size)
 {
-  if (madvise(reinterpret_cast<void*>(region), size, MADV_NORMAL)) {
+  if (posix_madvise(reinterpret_cast<char*>(region), size, MADV_NORMAL)) {
     return true;
   } else {
     return false;
diff --git a/ipc/chromium/src/base/platform_thread_posix.cc b/ipc/chromium/src/base/platform_thread_posix.cc
--- a/ipc/chromium/src/base/platform_thread_posix.cc
+++ b/ipc/chromium/src/base/platform_thread_posix.cc
@@ -27,6 +27,12 @@
 #include <pthread_np.h>
 #endif
 
+#if defined(OS_SOLARIS)
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <thread.h>
+#endif
+
 #if defined(OS_MACOSX)
 namespace base {
 void InitThreading();
@@ -50,6 +56,8 @@
   return port;
 #elif defined(OS_LINUX)
   return syscall(__NR_gettid);
+#elif defined(OS_SOLARIS)
+  return thr_self();
 #elif defined(OS_OPENBSD) || defined(__GLIBC__)
   return (intptr_t) (pthread_self());
 #elif defined(OS_NETBSD)

diff --git a/ipc/chromium/src/build/build_config.h b/ipc/chromium/src/build/build_config.h
--- a/ipc/chromium/src/build/build_config.h
+++ b/ipc/chromium/src/build/build_config.h
@@ -4,9 +4,9 @@
 
 // This file adds defines about the platform we're currently building on.
 //  Operating System:
-//    OS_WIN / OS_MACOSX / OS_LINUX / OS_POSIX (MACOSX or LINUX)
+//    OS_WIN / OS_MACOSX / OS_LINUX / OS_SOLARIS / OS_POSIX (MACOSX or LINUX)
 //  Compiler:
-//    COMPILER_MSVC / COMPILER_GCC
+//    COMPILER_MSVC / COMPILER_GCC / COMPILER_SUNPRO
 //  Processor:
 //    ARCH_CPU_X86 / ARCH_CPU_X86_64 / ARCH_CPU_X86_FAMILY (X86 or X86_64)
 //    ARCH_CPU_32_BITS / ARCH_CPU_64_BITS
@@ -27,6 +27,8 @@
 #define OS_NETBSD 1
 #elif defined(__OpenBSD__)
 #define OS_OPENBSD 1
+#elif defined(__sun__) || defined(__sun)
+#define OS_SOLARIS 1
 #elif defined(_WIN32)
 #define OS_WIN 1
 #else
@@ -42,13 +44,15 @@
 
 // For access to standard POSIX features, use OS_POSIX instead of a more
 // specific macro.
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
 #define OS_POSIX 1
 #endif
 
 // Compiler detection.
 #if defined(__GNUC__)
 #define COMPILER_GCC 1
+#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+#define COMPILER_SUNPRO 1
 #elif defined(_MSC_VER)
 #define COMPILER_MSVC 1
 #else
@@ -59,11 +63,11 @@
 //   http://msdn.microsoft.com/en-us/library/b0084kay.aspx
 //   http://www.agner.org/optimize/calling_conventions.pdf
 //   or with gcc, run: "echo | gcc -E -dM -"
-#if defined(_M_X64) || defined(__x86_64__)
+#if defined(_M_X64) || defined(__x86_64__) || defined(__x86_64)
 #define ARCH_CPU_X86_FAMILY 1
 #define ARCH_CPU_X86_64 1
 #define ARCH_CPU_64_BITS 1
-#elif defined(_M_IX86) || defined(__i386__)
+#elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
 #define ARCH_CPU_X86_FAMILY 1
 #define ARCH_CPU_X86 1
 #define ARCH_CPU_32_BITS 1
@@ -81,7 +85,7 @@
 #elif defined(__sparc64__)
 #define ARCH_CPU_SPARC 1
 #define ARCH_CPU_64_BITS 1
-#elif defined(__sparc__)
+#elif defined(__sparc__) || defined(__sparc)
 #define ARCH_CPU_SPARC 1
 #define ARCH_CPU_32_BITS 1
 #elif defined(__mips__)
diff --git a/ipc/chromium/src/base/port.h b/ipc/chromium/src/base/port.h
--- a/ipc/chromium/src/base/port.h
+++ b/ipc/chromium/src/base/port.h
@@ -45,7 +45,7 @@ namespace base {
 // use va_list as ref args to a function, as above, breaks some machines.
 #  if defined(COMPILER_GCC)
 #    define base_va_copy(_a, _b) ::va_copy(_a, _b)
-#  elif defined(COMPILER_MSVC)
+#  elif defined(COMPILER_MSVC) || defined(COMPILER_SUNPRO)
 #    define base_va_copy(_a, _b) (_a = _b)
 #  else
 #    error No va_copy for your compiler
@@ -56,7 +56,7 @@ namespace base {
 // Define an OS-neutral wrapper for shared library entry points
 #if defined(OS_WIN)
 #define API_CALL __stdcall
-#elif defined(OS_LINUX) || defined(OS_MACOSX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS) ||  defined(OS_MACOSX)
 #define API_CALL
 #endif
 
diff --git a/ipc/chromium/src/base/process_util.h b/ipc/chromium/src/base/process_util.h
index 914a34b..e3527d3 100644
--- a/ipc/chromium/src/base/process_util.h
+++ b/ipc/chromium/src/base/process_util.h
@@ -13,7 +13,7 @@
 #if defined(OS_WIN)
 #include <windows.h>
 #include <tlhelp32.h>
-#elif defined(OS_LINUX) || defined(__GLIBC__)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS) || defined(__GLIBC__)
 #include <dirent.h>
 #include <limits.h>
 #include <sys/types.h>
@@ -21,6 +21,10 @@
 #include <mach/mach.h>
 #endif
 
+#if defined(OS_SOLARIS)
+#define NAME_MAX 14
+#endif
+
 #include <map>
 #include <string>
 #include <vector>
@@ -62,7 +66,8 @@ enum ProcessArchitecture {
   PROCESS_ARCH_I386 = 0x1,
   PROCESS_ARCH_X86_64 = 0x2,
   PROCESS_ARCH_PPC = 0x4,
-  PROCESS_ARCH_ARM = 0x8
+  PROCESS_ARCH_ARM = 0x8,
+  PROCESS_ARCH_SPARC = 0x10
 };
 
 inline ProcessArchitecture GetCurrentProcessArchitecture()
@@ -76,6 +81,8 @@ inline ProcessArchitecture GetCurrentPro
   currentArchitecture = base::PROCESS_ARCH_PPC;
 #elif defined(ARCH_CPU_ARMEL)
   currentArchitecture = base::PROCESS_ARCH_ARM;
+#elif defined(ARCH_CPU_SPARC)
+  currentArchitecture = base::PROCESS_ARCH_SPARC;
 #endif
   return currentArchitecture;
 }
@@ -316,7 +323,7 @@ class NamedProcessIterator {
 #if defined(OS_WIN)
   HANDLE snapshot_;
   bool started_iteration_;
-#elif defined(OS_LINUX) || defined(__GLIBC__)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS) || defined(__GLIBC__)
   DIR *procfs_dir_;
 #elif defined(OS_BSD)
   std::vector<ProcessEntry> content;
diff --git a/ipc/chromium/src/base/platform_thread.h b/ipc/chromium/src/base/platform_thread.h
--- a/ipc/chromium/src/base/platform_thread.h
+++ b/ipc/chromium/src/base/platform_thread.h
@@ -22,7 +22,7 @@ typedef void* PlatformThreadHandle;  //
 #elif defined(OS_POSIX)
 #include <pthread.h>
 typedef pthread_t PlatformThreadHandle;
-#if defined(OS_LINUX) || defined(OS_OPENBSD) || defined(__GLIBC__)
+#if defined(OS_LINUX) || defined(OS_SOLARIS) || defined(OS_OPENBSD) || defined(__GLIBC__)
 #include <unistd.h>
 typedef pid_t PlatformThreadId;
 #elif defined(OS_BSD)
diff --git a/ipc/chromium/src/base/string16.h b/ipc/chromium/src/base/string16.h
index 28cf3d8..80d5e68 100644
--- a/ipc/chromium/src/base/string16.h
+++ b/ipc/chromium/src/base/string16.h
@@ -162,7 +162,9 @@ struct string16_char_traits {
 //
 // TODO(mark): File this bug with Apple and update this note with a bug number.
 
+#ifndef COMPILER_SUNPRO
 extern template class std::basic_string<char16, base::string16_char_traits>;
+#endif
 
 typedef std::basic_string<char16, base::string16_char_traits> string16;
 
diff --git a/ipc/chromium/src/base/string_piece.h b/ipc/chromium/src/base/string_piece.h
index fe10806..ae3106d 100644
--- a/ipc/chromium/src/base/string_piece.h
+++ b/ipc/chromium/src/base/string_piece.h
@@ -113,8 +113,13 @@ class StringPiece {
   static const size_type npos;
   typedef const char* const_iterator;
   typedef const char* iterator;
+#ifdef COMPILER_SUNPRO
+  typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag, const value_type> const_reverse_iterator;
+  typedef std::reverse_iterator<iterator, std::random_access_iterator_tag, value_type> reverse_iterator;
+#else
   typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
   typedef std::reverse_iterator<iterator> reverse_iterator;
+#endif
   iterator begin() const { return ptr_; }
   iterator end() const { return ptr_ + length_; }
   const_reverse_iterator rbegin() const {
diff --git a/ipc/chromium/src/base/sys_info_posix.cc b/ipc/chromium/src/base/sys_info_posix.cc
index 33ed0f7..b5bd350 100644
--- a/ipc/chromium/src/base/sys_info_posix.cc
+++ b/ipc/chromium/src/base/sys_info_posix.cc
@@ -119,7 +119,7 @@ std::wstring SysInfo::GetEnvVar(const wc
 
 // static
 std::string SysInfo::OperatingSystemName() {
-  utsname info;
+  struct utsname info;
   if (uname(&info) < 0) {
     NOTREACHED();
     return "";
@@ -129,7 +129,7 @@ std::string SysInfo::OperatingSystemName
 
 // static
 std::string SysInfo::OperatingSystemVersion() {
-  utsname info;
+  struct utsname info;
   if (uname(&info) < 0) {
     NOTREACHED();
     return "";
@@ -139,7 +139,7 @@ std::string SysInfo::OperatingSystemVers
 
 // static
 std::string SysInfo::CPUArchitecture() {
-  utsname info;
+  struct utsname info;
   if (uname(&info) < 0) {
     NOTREACHED();
     return "";
diff --git a/ipc/chromium/src/base/time.h b/ipc/chromium/src/base/time.h
index 0625bfb..a62f20d 100644
--- a/ipc/chromium/src/base/time.h
+++ b/ipc/chromium/src/base/time.h
@@ -62,6 +62,10 @@ class TimeDelta {
     return delta_;
   }
 
+#if defined(OS_POSIX)
+  struct timespec ToTimeSpec() const;
+#endif
+
   // Returns the time delta in some unit. The F versions return a floating
   // point value, the "regular" versions return a rounded-down value.
   int InDays() const;
@@ -224,6 +228,9 @@ class Time {
   static Time FromDoubleT(double dt);
   double ToDoubleT() const;
 
+#if defined(OS_POSIX)
+  struct timeval ToTimeVal() const;
+#endif
 
 #if defined(OS_WIN)
   static Time FromFileTime(FILETIME ft);
diff --git a/ipc/chromium/src/base/tracked_objects.cc b/ipc/chromium/src/base/tracked_objects.cc
index 7506df7..63cd557 100644
--- a/ipc/chromium/src/base/tracked_objects.cc
+++ b/ipc/chromium/src/base/tracked_objects.cc
@@ -804,7 +804,11 @@ void Comparator::SetSubgroupTiebreaker(S
 }
 
 void Comparator::ParseKeyphrase(const std::string key_phrase) {
+#if defined(COMPILER_SUNPRO)
+  static std::map<std::string, Selector> key_map;
+#else
   static std::map<const std::string, Selector> key_map;
+#endif
   static bool initialized = false;
   if (!initialized) {
     initialized = true;
diff --git a/ipc/chromium/src/chrome/common/chrome_constants.cc b/ipc/chromium/src/chrome/common/chrome_constants.cc
index 2ca8f0c..162b57f 100644
--- a/ipc/chromium/src/chrome/common/chrome_constants.cc
+++ b/ipc/chromium/src/chrome/common/chrome_constants.cc
@@ -14,7 +14,7 @@ namespace chrome {
 // for system strings only. UI changes should be made in the GRD.
 #if defined(OS_WIN)
 const wchar_t kBrowserProcessExecutableName[] = L"chrome.exe";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined (OS_SOLARIS)
 const wchar_t kBrowserProcessExecutableName[] = L"chrome";
 #elif defined(OS_MACOSX)
 const wchar_t kBrowserProcessExecutableName[] =
@@ -26,7 +26,7 @@ const wchar_t kBrowserProcessExecutableN
 #endif  // OS_*
 #if defined(OS_WIN)
 const wchar_t kBrowserProcessExecutablePath[] = L"chrome.exe";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined (OS_SOLARIS)
 const wchar_t kBrowserProcessExecutablePath[] = L"chrome";
 #elif defined(OS_MACOSX)
 const wchar_t kBrowserProcessExecutablePath[] =
diff --git a/ipc/chromium/src/chrome/common/file_descriptor_set_posix.cc b/ipc/chromium/src/chrome/common/file_descriptor_set_posix.cc
index 49d8199..006b483 100644
--- a/ipc/chromium/src/chrome/common/file_descriptor_set_posix.cc
+++ b/ipc/chromium/src/chrome/common/file_descriptor_set_posix.cc
@@ -4,6 +4,10 @@
 
 #include "chrome/common/file_descriptor_set_posix.h"
 
+#if defined(OS_SOLARIS)
+#include <unistd.h>
+#endif
+
 #include "base/eintr_wrapper.h"
 #include "base/logging.h"
 
diff --git a/ipc/glue/BrowserProcessSubThread.cpp b/ipc/glue/BrowserProcessSubThread.cpp
index e51db3c..6c0eb32 100644
--- a/ipc/glue/BrowserProcessSubThread.cpp
+++ b/ipc/glue/BrowserProcessSubThread.cpp
@@ -25,7 +25,7 @@ static const char* kBrowserThreadNames[B
 //  "Chrome_FileThread",  // FILE
 //  "Chrome_DBThread",  // DB
 //  "Chrome_HistoryThread",  // HISTORY
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined (OS_SOLARIS)
   "Gecko_Background_X11Thread",  // BACKGROUND_X11
 #endif
 };
@@ -36,7 +36,7 @@ BrowserProcessSubThread* BrowserProcessS
 //  NULL,  // FILE
 //  NULL,  // DB
 //  NULL,  // HISTORY
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined (OS_SOLARIS)
   NULL,  // BACKGROUND_X11
 #endif
 };
diff --git a/ipc/glue/BrowserProcessSubThread.h b/ipc/glue/BrowserProcessSubThread.h
index 68c8973..26bf0b3 100644
--- a/ipc/glue/BrowserProcessSubThread.h
+++ b/ipc/glue/BrowserProcessSubThread.h
@@ -28,7 +28,7 @@ public:
       //FILE,
       //DB,
       //HISTORY,
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined (OS_SOLARIS)
       // This thread has a second connection to the X server and is used
       // to process UI requests when routing the request to the UI
       // thread would risk deadlock.
diff --git a/ipc/ipdl/test/cxx/TestShutdown.cpp b/ipc/ipdl/test/cxx/TestShutdown.cpp
index 217aabc..6fe4dbd 100644
--- a/ipc/ipdl/test/cxx/TestShutdown.cpp
+++ b/ipc/ipdl/test/cxx/TestShutdown.cpp
@@ -184,6 +184,8 @@ TestShutdownChild::RecvStart()
         // detectors
         _exit(0);
     }
+
+       return false;
 }
 
 void
diff --git a/ipc/chromium/src/base/file_util_deprecated.h b/ipc/chromium/src/base/file_util_deprecated.h
new file mode 100644
index 0000000..9a8c5bf
--- /dev/null
+++ b/ipc/chromium/src/base/file_util_deprecated.h
@@ -0,0 +1,74 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// We're trying to transition away from paths as wstrings into using
+// FilePath objects.  This file contains declarations of deprecated
+// functions.  By hiding them here rather in the main header, we hope
+// to discourage callers.
+
+// See file_util.h for documentation on all functions that don't have
+// documentation here.
+
+#ifndef BASE_FILE_UTIL_DEPRECATED_H_
+#define BASE_FILE_UTIL_DEPRECATED_H_
+
+#include "build/build_config.h"
+
+namespace file_util {
+
+bool EndsWithSeparator(std::wstring* path);
+bool EndsWithSeparator(const std::wstring& path);
+
+// Use FilePath::DirName instead.
+void UpOneDirectory(std::wstring* dir);
+// Use FilePath::DirName instead.
+void UpOneDirectoryOrEmpty(std::wstring* dir);
+
+// Use FilePath::BaseName instead.
+std::wstring GetFilenameFromPath(const std::wstring& path);
+
+// Use FilePath::Extension instead.
+FilePath::StringType GetFileExtensionFromPath(const FilePath& path);
+std::wstring GetFileExtensionFromPath(const std::wstring& path);
+
+bool AbsolutePath(std::wstring* path);
+
+// Use FilePath::InsertBeforeExtension.
+void InsertBeforeExtension(FilePath* path, const FilePath::StringType& suffix);
+
+// Use FilePath::ReplaceExtension.
+void ReplaceExtension(FilePath* file_name,
+                      const FilePath::StringType& extension);
+
+bool Delete(const std::wstring& path, bool recursive);
+bool CopyDirectory(const std::wstring& from_path, const std::wstring& to_path,
+                   bool recursive);
+bool ReadFileToString(const std::wstring& path, std::string* contents);
+FILE* OpenFile(const std::string& filename, const char* mode);
+FILE* OpenFile(const std::wstring& filename, const char* mode);
+int ReadFile(const std::wstring& filename, char* data, int size);
+int WriteFile(const std::wstring& filename, const char* data, int size);
+
+// Functions successfully deprecated on non-Windows, but Win-specific
+// callers remain.
+#if defined(OS_WIN)
+// Returns the directory component of a path, without the trailing
+// path separator, or an empty string on error. The function does not
+// check for the existence of the path, so if it is passed a directory
+// without the trailing \, it will interpret the last component of the
+// path as a file and chomp it. This does not support relative paths.
+// Examples:
+// path == "C:\pics\jojo.jpg",     returns "C:\pics"
+// path == "C:\Windows\system32\", returns "C:\Windows\system32"
+// path == "C:\Windows\system32",  returns "C:\Windows"
+// Deprecated. Use FilePath's DirName() instead.
+std::wstring GetDirectoryFromPath(const std::wstring& path);
+
+// Appends new_ending to path, adding a separator between the two if necessary.
+void AppendToPath(std::wstring* path, const std::wstring& new_ending);
+#endif
+
+}
+
+#endif  // BASE_FILE_UTIL_DEPRECATED_H_
diff --git a/ipc/chromium/src/base/string_util.cc b/ipc/chromium/src/base/string_util.cc
--- a/ipc/chromium/src/base/string_util.cc
+++ b/ipc/chromium/src/base/string_util.cc
@@ -498,32 +498,56 @@ std::wstring CollapseWhitespace(const st
   }
 
   result.resize(chars_written);
   return result;
 }
 
 std::string WideToASCII(const std::wstring& wide) {
   DCHECK(IsStringASCII(wide));
+#ifdef COMPILER_SUNPRO
+  std::string str(wide.length(), ' ');
+  std::copy(wide.begin(), wide.end(), str.begin());
+  return str;
+#else
   return std::string(wide.begin(), wide.end());
+#endif
 }
 
 std::wstring ASCIIToWide(const std::string& ascii) {
   DCHECK(IsStringASCII(ascii));
+#ifdef COMPILER_SUNPRO
+  std::wstring wstr(ascii.length(), L' ');
+  std::copy(ascii.begin(), ascii.end(), wstr.begin());
+  return wstr;
+#else
   return std::wstring(ascii.begin(), ascii.end());
+#endif
 }
 
 std::string UTF16ToASCII(const string16& utf16) {
   DCHECK(IsStringASCII(utf16));
+#ifdef COMPILER_SUNPRO
+  std::string str(utf16.length(), ' ');
+  std::copy(utf16.begin(), utf16.end(), str.begin());
+  return str;
+#else
   return std::string(utf16.begin(), utf16.end());
+#endif
 }
 
 string16 ASCIIToUTF16(const std::string& ascii) {
   DCHECK(IsStringASCII(ascii));
+#ifdef COMPILER_SUNPRO
+  string16 str(ascii.length(), ' ');
+  std::copy(ascii.begin(), ascii.end(), str.begin());
+  return str;
+#else
   return string16(ascii.begin(), ascii.end());
+#endif
 }
 
 // Latin1 is just the low range of Unicode, so we can copy directly to convert.
 bool WideToLatin1(const std::wstring& wide, std::string* latin1) {
   std::string output;
   output.resize(wide.size());
   latin1->clear();
   for (size_t i = 0; i < wide.size(); i++) {
@@ -730,17 +754,17 @@ bool LowerCaseEqualsASCII(std::string::c
 }
 
 bool LowerCaseEqualsASCII(std::wstring::const_iterator a_begin,
                           std::wstring::const_iterator a_end,
                           const char* b) {
   return DoLowerCaseEqualsASCII(a_begin, a_end, b);
 }
 
-#ifndef ANDROID
+#if !defined(COMPILER_SUNPRO) && !defined(ANDROID)
 bool LowerCaseEqualsASCII(const char* a_begin,
                           const char* a_end,
                           const char* b) {
   return DoLowerCaseEqualsASCII(a_begin, a_end, b);
 }
 bool LowerCaseEqualsASCII(const wchar_t* a_begin,
                           const wchar_t* a_end,
                           const char* b) {
diff --git a/ipc/chromium/src/base/atomicops.h b/ipc/chromium/src/base/atomicops.h
--- a/ipc/chromium/src/base/atomicops.h
+++ b/ipc/chromium/src/base/atomicops.h
@@ -129,16 +129,20 @@ Atomic64 Release_Load(volatile const Ato
 
 // Include our platform specific implementation.
 #if defined(OS_WIN) && defined(ARCH_CPU_X86_FAMILY)
 #include "base/atomicops_internals_x86_msvc.h"
 #elif defined(OS_MACOSX) && defined(ARCH_CPU_X86_FAMILY)
 #include "base/atomicops_internals_x86_macosx.h"
 #elif defined(COMPILER_GCC) && defined(ARCH_CPU_X86_FAMILY)
 #include "base/atomicops_internals_x86_gcc.h"
+#elif defined(COMPILER_SUNPRO) && defined(ARCH_CPU_X86_FAMILY)
+#define __asm__ asm
+#define __volatile__ volatile
+#include "base/atomicops_internals_x86_gcc.h"
 #elif defined(COMPILER_GCC) && defined(ARCH_CPU_ARM_FAMILY)
 #include "base/atomicops_internals_arm_gcc.h"
 #elif defined(COMPILER_GCC) && defined(ARCH_CPU_MIPS)
 #include "base/atomicops_internals_mips_gcc.h"
 #else
 #include "base/atomicops_internals_mutex.h"
 #endif
 
diff --git a/ipc/chromium/src/base/message_pump_libevent.cc b/ipc/chromium/src/base/message_pump_libevent.cc
--- a/ipc/chromium/src/base/message_pump_libevent.cc
+++ b/ipc/chromium/src/base/message_pump_libevent.cc
@@ -1,16 +1,20 @@
 // Copyright (c) 2008 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 #include "base/message_pump_libevent.h"
 
 #include <errno.h>
 #include <fcntl.h>
+#if defined(OS_SOLARIS)
+#include <unistd.h>
+#include <sys/stat.h>
+#endif
 #if defined(ANDROID) || defined(OS_POSIX)
 #include <unistd.h>
 #endif
 
 #include "eintr_wrapper.h"
 #include "base/logging.h"
 #include "base/scoped_nsautorelease_pool.h"
 #include "base/scoped_ptr.h"
diff --git a/dom/plugins/ipc/PluginModuleChild.cpp b/dom/plugins/ipc/PluginModuleChild.cpp
--- a/dom/plugins/ipc/PluginModuleChild.cpp
+++ b/dom/plugins/ipc/PluginModuleChild.cpp
@@ -198,7 +198,7 @@
 
     // TODO: use PluginPRLibrary here
 
-#if defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
     mShutdownFunc =
         (NP_PLUGINSHUTDOWN) PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
 
@@ -236,9 +236,11 @@
 }
 
 #if defined(MOZ_WIDGET_GTK)
+extern "C" {
 typedef void (*GObjectDisposeFn)(GObject*);
 typedef gboolean (*GtkWidgetScrollEventFn)(GtkWidget*, GdkEventScroll*);
 typedef void (*GtkPlugEmbeddedFn)(GtkPlug*);
+}
 
 static GObjectDisposeFn real_gtk_plug_dispose;
 static GtkPlugEmbeddedFn real_gtk_plug_embedded;
@@ -1829,7 +1831,7 @@
     PLUGIN_LOG_DEBUG_METHOD;
     AssertPluginThread();
 
-#if defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
     return true;
 #elif defined(OS_WIN) || defined(OS_MACOSX)
     *_retval = mGetEntryPointsFunc(&mFunctions);
@@ -1858,7 +1860,7 @@
     SendBackUpXResources(FileDescriptor(xSocketFd));
 #endif
 
-#if defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
     *_retval = mInitializeFunc(&sBrowserFuncs, &mFunctions);
     return true;
 #elif defined(OS_WIN) || defined(OS_MACOSX)
diff --git a/dom/plugins/ipc/PluginModuleChild.h b/dom/plugins/ipc/PluginModuleChild.h
--- a/dom/plugins/ipc/PluginModuleChild.h
+++ b/dom/plugins/ipc/PluginModuleChild.h
@@ -320,7 +320,7 @@
 
     // we get this from the plugin
     NP_PLUGINSHUTDOWN mShutdownFunc;
-#if defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
     NP_PLUGINUNIXINIT mInitializeFunc;
 #elif defined(OS_WIN) || defined(OS_MACOSX)
     NP_PLUGININIT mInitializeFunc;
diff --git a/ipc/chromium/src/base/base_paths.h b/ipc/chromium/src/base/base_paths.h
--- a/ipc/chromium/src/base/base_paths.h
+++ b/ipc/chromium/src/base/base_paths.h
@@ -13,7 +13,7 @@
 #include "base/base_paths_win.h"
 #elif defined(OS_MACOSX)
 #include "base/base_paths_mac.h"
-#elif defined(OS_LINUX) || defined(OS_BSD)
+#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
 #include "base/base_paths_linux.h"
 #endif
 #include "base/path_service.h"
diff --git a/ipc/chromium/src/base/debug_util_posix.cc b/ipc/chromium/src/base/debug_util_posix.cc
--- a/ipc/chromium/src/base/debug_util_posix.cc
+++ b/ipc/chromium/src/base/debug_util_posix.cc
@@ -90,7 +90,7 @@
   return being_debugged;
 }
 
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 
 // We can look in /proc/self/status for TracerPid.  We are likely used in crash
 // handling, so we are careful not to use the heap or have side effects.
@@ -125,13 +125,17 @@
   return pid_index < status.size() && status[pid_index] != '0';
 }
 
-#endif  // OS_LINUX
+#endif  // OS_LINUX || OS_SOLARIS
 
 // static
 void DebugUtil::BreakDebugger() {
 #if defined(ARCH_CPU_X86_FAMILY)
+#if defined(COMPILER_SUNPRO)
+  asm ("int $3");
+#else
   asm ("int3");
 #endif
+#endif
 }
 
 StackTrace::StackTrace() {
diff --git a/ipc/chromium/src/base/message_loop.cc b/ipc/chromium/src/base/message_loop.cc
--- a/ipc/chromium/src/base/message_loop.cc
+++ b/ipc/chromium/src/base/message_loop.cc
@@ -19,7 +19,7 @@
 #if defined(OS_POSIX)
 #include "base/message_pump_libevent.h"
 #endif
-#if defined(OS_LINUX) || defined(OS_BSD)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
 #if defined(MOZ_WIDGET_GTK)
 #include "base/message_pump_glib.h"
 #endif
@@ -130,9 +130,9 @@
   if (type_ == TYPE_UI) {
 #if defined(OS_MACOSX)
     pump_ = base::MessagePumpMac::Create();
-#elif defined(OS_LINUX) || defined(OS_BSD)
+#elif defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
     pump_ = new base::MessagePumpForUI();
-#endif  // OS_LINUX
+#endif  // OS_LINUX || OS_SOLARIS
   } else if (type_ == TYPE_IO) {
     pump_ = new base::MessagePumpLibevent();
   } else {
diff --git a/ipc/chromium/src/chrome/common/ipc_channel_posix.h b/ipc/chromium/src/chrome/common/ipc_channel_posix.h
--- a/ipc/chromium/src/chrome/common/ipc_channel_posix.h
+++ b/ipc/chromium/src/chrome/common/ipc_channel_posix.h
@@ -95,7 +95,7 @@
   };
 
   // This is a control message buffer large enough to hold kMaxReadFDs
-#if defined(OS_MACOSX) || defined(OS_NETBSD)
+#if defined(OS_MACOSX) || defined(OS_NETBSD) || defined(OS_SOLARIS)
   // TODO(agl): OSX appears to have non-constant CMSG macros!
   char input_cmsg_buf_[1024];
 #else
diff --git a/ipc/glue/SharedMemorySysV.h b/ipc/glue/SharedMemorySysV.h
--- a/ipc/glue/SharedMemorySysV.h
+++ b/ipc/glue/SharedMemorySysV.h
@@ -8,7 +8,7 @@
 #ifndef mozilla_ipc_SharedMemorySysV_h
 #define mozilla_ipc_SharedMemorySysV_h
 
-#if (defined(OS_LINUX) && !defined(ANDROID)) || defined(OS_BSD)
+#if (defined(OS_LINUX) && !defined(ANDROID)) || defined(OS_BSD) || defined(OS_SOLARIS)
 
 // SysV shared memory isn't available on Windows, but we define the
 // following macro so that #ifdefs are clearer (compared to #ifdef
@@ -55,6 +55,9 @@
   virtual ~SharedMemorySysV()
   {
     shmdt(mData);
+#ifdef OS_SOLARIS    
+    shmctl(mHandle, IPC_RMID, 0);
+#endif    
     mHandle = -1;
     mData = nullptr;
   }
@@ -94,7 +97,9 @@
 
     // Mark the handle as deleted so that, should this process go away, the
     // segment is cleaned up.
+#ifndef OS_SOLARIS
     shmctl(mHandle, IPC_RMID, 0);
+#endif
 
     mData = mem;
 
@@ -145,6 +150,6 @@
 } // namespace ipc
 } // namespace mozilla
 
-#endif // OS_LINUX
+#endif // OS_LINUX || OS_SOLARIS
 
 #endif // ifndef mozilla_ipc_SharedMemorySysV_h
diff --git a/ipc/chromium/src/base/pickle.cc b/ipc/chromium/src/base/pickle.cc
--- a/ipc/chromium/src/base/pickle.cc
+++ b/ipc/chromium/src/base/pickle.cc
@@ -12,6 +12,7 @@
 
 #include <limits>
 #include <string>
+#include <algorithm>
 
 //------------------------------------------------------------------------------
 
diff --git a/ipc/chromium/src/chrome/common/ipc_message.h b/ipc/chromium/src/chrome/common/ipc_message.h
--- a/ipc/chromium/src/chrome/common/ipc_message.h
+++ b/ipc/chromium/src/chrome/common/ipc_message.h
@@ -278,7 +278,11 @@
     COMPRESS_BIT    = 0x0200
   };
 
+#if defined(COMPILER_SUNPRO)
+#pragma pack (2)
+#else
 #pragma pack(push, 2)
+#endif
   struct Header : Pickle::Header {
     int32_t routing;  // ID of the view that this message is destined for
     msgid_t type;   // specifies the user-defined message type
@@ -293,7 +297,11 @@
     // Sequence number
     int32_t seqno;
   };
+#if defined(COMPILER_SUNPRO)
+#pragma pack (0)
+#else
 #pragma pack(pop)
+#endif
 
   Header* header() {
     return headerT<Header>();
diff --git a/ipc/chromium/src/base/file_util.cc b/ipc/chromium/src/base/file_util.cc
--- a/ipc/chromium/src/base/file_util.cc
+++ b/ipc/chromium/src/base/file_util.cc
@@ -16,11 +16,9 @@
 
 #include "base/file_path.h"
 #include "base/logging.h"
+#include "base/string_piece.h"
 #include "base/string_util.h"
 
-#include "base/string_piece.h"
-#include "base/sys_string_conversions.h"
-
 namespace {
 
 const FilePath::CharType kExtensionSeparator = FILE_PATH_LITERAL('.');
@@ -29,34 +27,6 @@
 
 namespace file_util {
 
-void PathComponents(const FilePath& path,
-                    std::vector<FilePath::StringType>* components) {
-  DCHECK(components);
-  if (!components)
-    return;
-
-  FilePath::StringType path_str = path.value();
-  FilePath::StringType::size_type start = 0;
-  FilePath::StringType::size_type end =
-      path_str.find_first_of(FilePath::kSeparators);
-
-  // If the path starts with a separator, add it to components.
-  if (end == start) {
-    components->push_back(FilePath::StringType(path_str, 0, 1));
-    start = end + 1;
-    end = path_str.find_first_of(FilePath::kSeparators, start);
-  }
-  while (end != FilePath::StringType::npos) {
-    FilePath::StringType component =
-        FilePath::StringType(path_str, start, end - start);
-    components->push_back(component);
-    start = end + 1;
-    end = path_str.find_first_of(FilePath::kSeparators, start);
-  }
-
-  components->push_back(FilePath::StringType(path_str, start));
-}
-
 bool EndsWithSeparator(const FilePath& path) {
   FilePath::StringType value = path.value();
   if (value.empty())
@@ -79,11 +49,6 @@
   return true;
 }
 
-void TrimTrailingSeparator(std::wstring* dir) {
-  while (dir->length() > 1 && EndsWithSeparator(dir))
-    dir->resize(dir->length() - 1);
-}
-
 FilePath::StringType GetFileExtensionFromPath(const FilePath& path) {
   FilePath::StringType file_name = path.BaseName().value();
   const FilePath::StringType::size_type last_dot =
@@ -160,21 +125,60 @@
     file1.read(buffer1, BUFFER_SIZE);
     file2.read(buffer2, BUFFER_SIZE);
 
-    if ((file1.eof() && !file2.eof()) ||
-        (!file1.eof() && file2.eof()) ||
+    if ((file1.eof() != file2.eof()) ||
         (file1.gcount() != file2.gcount()) ||
         (memcmp(buffer1, buffer2, file1.gcount()))) {
       file1.close();
       file2.close();
       return false;
     }
-  } while (!file1.eof() && !file2.eof());
+  } while (!file1.eof() || !file2.eof());
 
   file1.close();
   file2.close();
   return true;
 }
 
+bool TextContentsEqual(const FilePath& filename1, const FilePath& filename2) {
+  std::ifstream file1(filename1.value().c_str(), std::ios::in);
+  std::ifstream file2(filename2.value().c_str(), std::ios::in);
+
+  // Even if both files aren't openable (and thus, in some sense, "equal"),
+  // any unusable file yields a result of "false".
+  if (!file1.is_open() || !file2.is_open())
+    return false;
+
+  do {
+    std::string line1, line2;
+    getline(file1, line1);
+    getline(file2, line2);
+
+    // Check for mismatched EOF states, or any error state.
+    if ((file1.eof() != file2.eof()) ||
+        file1.bad() || file2.bad()) {
+      return false;
+    }
+
+    // Trim all '\r' and '\n' characters from the end of the line.
+    std::string::size_type end1 = line1.find_last_not_of("\r\n");
+    if (end1 == std::string::npos)
+      line1.clear();
+    else if (end1 + 1 < line1.length())
+      line1.erase(end1 + 1);
+
+    std::string::size_type end2 = line2.find_last_not_of("\r\n");
+    if (end2 == std::string::npos)
+      line2.clear();
+    else if (end2 + 1 < line2.length())
+      line2.erase(end2 + 1);
+
+    if (line1 != line2)
+      return false;
+  } while (!file1.eof() || !file2.eof());
+
+  return true;
+}
+
 bool ReadFileToString(const FilePath& path, std::string* contents) {
   FILE* file = OpenFile(path, "rb");
   if (!file) {
@@ -207,6 +211,14 @@
   return true;
 }
 
+bool IsDot(const FilePath& path) {
+  return FILE_PATH_LITERAL(".") == path.BaseName().value();
+}
+
+bool IsDotDot(const FilePath& path) {
+  return FILE_PATH_LITERAL("..") == path.BaseName().value();
+}
+
 bool CloseFile(FILE* file) {
   if (file == NULL)
     return true;
@@ -258,6 +270,23 @@
   return true;
 }
 
+int64_t ComputeDirectorySize(const FilePath& root_path) {
+  int64_t running_size = 0;
+  FileEnumerator file_iter(root_path, true, FileEnumerator::FILES);
+  for (FilePath current = file_iter.Next(); !current.empty();
+       current = file_iter.Next()) {
+    FileEnumerator::FindInfo info;
+    file_iter.GetFindInfo(&info);
+#if defined(OS_WIN)
+    LARGE_INTEGER li = { info.nFileSizeLow, info.nFileSizeHigh };
+    running_size += li.QuadPart;
+#else
+    running_size += info.stat.st_size;
+#endif
+  }
+  return running_size;
+}
+
 ///////////////////////////////////////////////
 // MemoryMappedFile
 
@@ -265,6 +294,20 @@
   CloseHandles();
 }
 
+bool MemoryMappedFile::Initialize(base::PlatformFile file) {
+  if (IsValid())
+    return false;
+
+  file_ = file;
+
+  if (!MapFileToMemoryInternal()) {
+    CloseHandles();
+    return false;
+  }
+
+  return true;
+}
+
 bool MemoryMappedFile::Initialize(const FilePath& file_name) {
   if (IsValid())
     return false;
@@ -277,6 +320,19 @@
   return true;
 }
 
+bool MemoryMappedFile::MapFileToMemory(const FilePath& file_name) {
+  file_ = base::CreatePlatformFile(file_name.ToWStringHack(),
+      base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_READ,
+      NULL);
+
+  if (file_ == base::kInvalidPlatformFileValue) {
+    LOG(ERROR) << "Couldn't open " << file_name.value();
+    return false;
+  }
+
+  return MapFileToMemoryInternal();
+}
+
 bool MemoryMappedFile::IsValid() {
   return data_ != NULL;
 }
@@ -294,73 +350,33 @@
   *path_str = path.ToWStringHack();
   return true;
 }
+
+#if defined(OS_WIN)
+// This function is deprecated; see file_util_deprecated.h for details.
 void AppendToPath(std::wstring* path, const std::wstring& new_ending) {
   if (!path) {
     NOTREACHED();
     return;  // Don't crash in this function in release builds.
   }
 
-  if (!EndsWithSeparator(path))
+  if (!EndsWithSeparator(*path))
     path->push_back(FilePath::kSeparators[0]);
   path->append(new_ending);
 }
+#endif
+
 bool CopyDirectory(const std::wstring& from_path, const std::wstring& to_path,
                    bool recursive) {
   return CopyDirectory(FilePath::FromWStringHack(from_path),
                        FilePath::FromWStringHack(to_path),
                        recursive);
 }
-bool ContentsEqual(const std::wstring& filename1,
-                   const std::wstring& filename2) {
-  return ContentsEqual(FilePath::FromWStringHack(filename1),
-                       FilePath::FromWStringHack(filename2));
-}
-bool CopyFile(const std::wstring& from_path, const std::wstring& to_path) {
-  return CopyFile(FilePath::FromWStringHack(from_path),
-                  FilePath::FromWStringHack(to_path));
-}
-bool CreateDirectory(const std::wstring& full_path) {
-  return CreateDirectory(FilePath::FromWStringHack(full_path));
-}
-bool CreateNewTempDirectory(const std::wstring& prefix,
-                            std::wstring* new_temp_path) {
-#if defined(OS_WIN)
-  FilePath::StringType dir_prefix(prefix);
-#elif defined(OS_POSIX)
-  FilePath::StringType dir_prefix = WideToUTF8(prefix);
-#endif
-  FilePath temp_path;
-  if (!CreateNewTempDirectory(dir_prefix, &temp_path))
-    return false;
-  *new_temp_path = temp_path.ToWStringHack();
-  return true;
-}
-bool CreateTemporaryFileName(std::wstring* temp_file) {
-  FilePath temp_file_path;
-  if (!CreateTemporaryFileName(&temp_file_path))
-    return false;
-  *temp_file = temp_file_path.ToWStringHack();
-  return true;
-}
 bool Delete(const std::wstring& path, bool recursive) {
   return Delete(FilePath::FromWStringHack(path), recursive);
 }
-bool DirectoryExists(const std::wstring& path) {
-  return DirectoryExists(FilePath::FromWStringHack(path));
-}
-bool EndsWithSeparator(std::wstring* path) {
-  return EndsWithSeparator(FilePath::FromWStringHack(*path));
-}
 bool EndsWithSeparator(const std::wstring& path) {
   return EndsWithSeparator(FilePath::FromWStringHack(path));
 }
-bool GetCurrentDirectory(std::wstring* path_str) {
-  FilePath path;
-  if (!GetCurrentDirectory(&path))
-    return false;
-  *path_str = path.ToWStringHack();
-  return true;
-}
 std::wstring GetFileExtensionFromPath(const std::wstring& path) {
   FilePath::StringType extension =
       GetFileExtensionFromPath(FilePath::FromWStringHack(path));
@@ -370,9 +386,6 @@
   return UTF8ToWide(extension);
 #endif
 }
-bool GetFileInfo(const std::wstring& file_path, FileInfo* results) {
-  return GetFileInfo(FilePath::FromWStringHack(file_path), results);
-}
 std::wstring GetFilenameFromPath(const std::wstring& path) {
   if (path.empty() || EndsWithSeparator(path))
     return std::wstring();
@@ -396,18 +409,9 @@
 FILE* OpenFile(const std::wstring& filename, const char* mode) {
   return OpenFile(FilePath::FromWStringHack(filename), mode);
 }
-bool PathExists(const std::wstring& path) {
-  return PathExists(FilePath::FromWStringHack(path));
-}
-bool PathIsWritable(const std::wstring& path) {
-  return PathIsWritable(FilePath::FromWStringHack(path));
-}
 int ReadFile(const std::wstring& filename, char* data, int size) {
   return ReadFile(FilePath::FromWStringHack(filename), data, size);
 }
-bool SetCurrentDirectory(const std::wstring& directory) {
-  return SetCurrentDirectory(FilePath::FromWStringHack(directory));
-}
 void UpOneDirectory(std::wstring* dir) {
   FilePath path = FilePath::FromWStringHack(*dir);
   FilePath directory = path.DirName();
@@ -429,4 +433,15 @@
 int WriteFile(const std::wstring& filename, const char* data, int size) {
   return WriteFile(FilePath::FromWStringHack(filename), data, size);
 }
+
+///////////////////////////////////////////////
+// FileEnumerator
+//
+// Note: the main logic is in file_util_<platform>.cc
+
+bool FileEnumerator::ShouldSkip(const FilePath& path) {
+  FilePath::StringType basename = path.BaseName().value();
+  return IsDot(path) || (IsDotDot(path) && !(INCLUDE_DOT_DOT & file_type_));
+}
+
 }  // namespace
diff --git a/ipc/chromium/src/base/time_posix.cc b/ipc/chromium/src/base/time_posix.cc
--- a/ipc/chromium/src/base/time_posix.cc
+++ b/ipc/chromium/src/base/time_posix.cc
@@ -65,11 +65,13 @@
   timestruct.tm_wday   = exploded.day_of_week;  // mktime/timegm ignore this
   timestruct.tm_yday   = 0;     // mktime/timegm ignore this
   timestruct.tm_isdst  = -1;    // attempt to figure it out
+#ifndef OS_SOLARIS
   timestruct.tm_gmtoff = 0;     // not a POSIX field, so mktime/timegm ignore
   timestruct.tm_zone   = NULL;  // not a POSIX field, so mktime/timegm ignore
-
+#endif
+  
   time_t seconds;
-#ifdef ANDROID
+#if defined(ANDROID) || defined(OS_SOLARIS)
     seconds = mktime(&timestruct);
 #else
   if (is_local)
@@ -167,7 +169,7 @@
   // With numer and denom = 1 (the expected case), the 64-bit absolute time
   // reported in nanoseconds is enough to last nearly 585 years.
 
-#elif defined(OS_OPENBSD) || defined(OS_POSIX) && \
+#elif defined(OS_OPENBSD) || defined(OS_SOLARIS) || defined(OS_POSIX) && \
       defined(_POSIX_MONOTONIC_CLOCK) && _POSIX_MONOTONIC_CLOCK >= 0
 
   struct timespec ts;
@@ -192,4 +194,25 @@
   return Now();
 }
 
+struct timespec TimeDelta::ToTimeSpec() const {
+  int64_t microseconds = InMicroseconds();
+  time_t seconds = 0;
+  if (microseconds >= Time::kMicrosecondsPerSecond) {
+    seconds = InSeconds();
+    microseconds -= seconds * Time::kMicrosecondsPerSecond;
+  }
+  struct timespec result =
+      {seconds,
+       microseconds * Time::kNanosecondsPerMicrosecond};
+  return result;
+}
+
+struct timeval Time::ToTimeVal() const {
+  struct timeval result;
+  int64_t us = us_ - kTimeTToMicrosecondsOffset;
+  result.tv_sec = us / Time::kMicrosecondsPerSecond;
+  result.tv_usec = us % Time::kMicrosecondsPerSecond;
+  return result;
+}
+
 }  // namespace base
diff --git a/ipc/chromium/src/base/file_util.h b/ipc/chromium/src/base/file_util.h
--- a/ipc/chromium/src/base/file_util.h
+++ b/ipc/chromium/src/base/file_util.h
@@ -1,205 +1,149 @@
-// Copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
 // This file contains utility functions for dealing with the local
 // filesystem.
 
 #ifndef BASE_FILE_UTIL_H_
 #define BASE_FILE_UTIL_H_
 
 #include "build/build_config.h"
 
 #if defined(OS_WIN)
 #include <windows.h>
-#elif defined(ANDROID)
+#elif defined(ANDROID) || defined(OS_SOLARIS)
 #include <sys/stat.h>
 #elif defined(OS_POSIX) 
 #include <sys/types.h>
 #include <fts.h>
 #include <sys/stat.h>
 #endif
 
 #include <stdio.h>
 
 #include <stack>
 #include <string>
 #include <vector>
 
 #include "base/basictypes.h"
+#include "base/file_path.h"
+#include "base/platform_file.h"
 #include "base/scoped_ptr.h"
-#include "base/file_path.h"
+#include "base/string16.h"
+#include "base/time.h"
+
+#include "unistd.h"
+
+#if defined(OS_POSIX)
+#include "base/eintr_wrapper.h"
+#include "base/file_descriptor_posix.h"
+#endif
 
 namespace base {
 class Time;
 }
 
 namespace file_util {
 
 //-----------------------------------------------------------------------------
 // Functions that operate purely on a path string w/o touching the filesystem:
 
-// Returns a vector of all of the components of the provided path.
-void PathComponents(const FilePath& path,
-                    std::vector<FilePath::StringType>* components);
-#if defined(OS_WIN)
-// Deprecated temporary compatibility function.
-void PathComponents(const std::wstring& path,
-                    std::vector<std::wstring>* components);
-#endif
-
 // Returns true if the given path ends with a path separator character.
 bool EndsWithSeparator(const FilePath& path);
-// These two versions are both deprecated. TODO(estade): remove them.
-bool EndsWithSeparator(std::wstring* path);
-bool EndsWithSeparator(const std::wstring& path);
 
 // Makes sure that |path| ends with a separator IFF path is a directory that
 // exists. Returns true if |path| is an existing directory, false otherwise.
 bool EnsureEndsWithSeparator(FilePath* path);
 
-// Modifies a string by trimming all trailing separators from the end.
-// Deprecated. FilePath does this automatically, and if it's constructed from a
-// path with a trailing separator, StripTrailingSeparators() may be used.
-void TrimTrailingSeparator(std::wstring* dir);
-
-// Strips the topmost directory from the end of 'dir'.  Assumes 'dir' does not
-// refer to a file.
-// If 'dir' is a root directory, return without change.
-// Deprecated. Use FilePath::DirName instead.
-void UpOneDirectory(std::wstring* dir);
-// Strips the topmost directory from the end of 'dir'.  Assumes 'dir' does not
-// refer to a file.
-// If 'dir' is a root directory, the result becomes empty string.
-// Deprecated. Use FilePath::DirName instead.
-void UpOneDirectoryOrEmpty(std::wstring* dir);
-
-// Returns the filename portion of 'path', without any leading \'s or /'s.
-// Deprecated. Use FilePath::BaseName instead.
-std::wstring GetFilenameFromPath(const std::wstring& path);
-
-// Deprecated compatibility function.  Use FilePath::Extension.
-FilePath::StringType GetFileExtensionFromPath(const FilePath& path);
-// Deprecated temporary compatibility function.
-std::wstring GetFileExtensionFromPath(const std::wstring& path);
-
-// Returns the directory component of a path, without the trailing
-// path separator, or an empty string on error. The function does not
-// check for the existence of the path, so if it is passed a directory
-// without the trailing \, it will interpret the last component of the
-// path as a file and chomp it. This does not support relative paths.
-// Examples:
-// path == "C:\pics\jojo.jpg",     returns "C:\pics"
-// path == "C:\Windows\system32\", returns "C:\Windows\system32"
-// path == "C:\Windows\system32",  returns "C:\Windows"
-std::wstring GetDirectoryFromPath(const std::wstring& path);
-
-// Appends new_ending to path, adding a separator between the two if necessary.
-void AppendToPath(std::wstring* path, const std::wstring& new_ending);
-
 // Convert provided relative path into an absolute path.  Returns false on
 // error. On POSIX, this function fails if the path does not exist.
 bool AbsolutePath(FilePath* path);
-// Deprecated temporary compatibility function.
-bool AbsolutePath(std::wstring* path);
 
 // Returns true if |parent| contains |child|. Both paths are converted to
 // absolute paths before doing the comparison.
 bool ContainsPath(const FilePath& parent, const FilePath& child);
 
-// Deprecated compatibility function.  Use FilePath::InsertBeforeExtension.
-void InsertBeforeExtension(FilePath* path, const FilePath::StringType& suffix);
-
-// Deprecated compatibility function.  Use FilePath::ReplaceExtension.
-void ReplaceExtension(FilePath* file_name,
-                      const FilePath::StringType& extension);
-
-#if defined(OS_WIN)
-// Deprecated temporary compatibility functions.
-void InsertBeforeExtension(std::wstring* path, const std::wstring& suffix);
-void ReplaceExtension(std::wstring* file_name, const std::wstring& extension);
-#endif
-
-// Replaces characters in 'file_name' that are illegal for file names with
-// 'replace_char'. 'file_name' must not be a full or relative path, but just the
-// file name component. Any leading or trailing whitespace in 'file_name' is
-// removed.
-// Example:
-//   file_name == "bad:file*name?.txt", changed to: "bad-file-name-.txt" when
-//   'replace_char' is '-'.
-void ReplaceIllegalCharacters(std::wstring* file_name, int replace_char);
-
 //-----------------------------------------------------------------------------
 // Functions that involve filesystem access or modification:
 
+// Returns the number of files matching the current path that were
 // created on or after the given |file_time|.  Doesn't count ".." or ".".
 //
 // Note for POSIX environments: a file created before |file_time|
 // can be mis-detected as a newer file due to low precision of
 // timestmap of file creation time. If you need to avoid such
 // mis-detection perfectly, you should wait one second before
 // obtaining |file_time|.
 int CountFilesCreatedAfter(const FilePath& path,
                            const base::Time& file_time);
 
+// Returns the total number of bytes used by all the files under |root_path|.
+// If the path does not exist the function returns 0.
+//
+// This function is implemented using the FileEnumerator class so it is not
+// particularly speedy in any platform.
+int64_t ComputeDirectorySize(const FilePath& root_path);
+
 // Deletes the given path, whether it's a file or a directory.
 // If it's a directory, it's perfectly happy to delete all of the
 // directory's contents.  Passing true to recursive deletes
 // subdirectories and their contents as well.
 // Returns true if successful, false otherwise.
 //
 // WARNING: USING THIS WITH recursive==true IS EQUIVALENT
 //          TO "rm -rf", SO USE WITH CAUTION.
 bool Delete(const FilePath& path, bool recursive);
-// Deprecated temporary compatibility function.
-bool Delete(const std::wstring& path, bool recursive);
+
+#if defined(OS_WIN)
+// Schedules to delete the given path, whether it's a file or a directory, until
+// the operating system is restarted.
+// Note:
+// 1) The file/directory to be deleted should exist in a temp folder.
+// 2) The directory to be deleted must be empty.
+bool DeleteAfterReboot(const FilePath& path);
+#endif
 
 // Moves the given path, whether it's a file or a directory.
 // If a simple rename is not possible, such as in the case where the paths are
 // on different volumes, this will attempt to copy and delete. Returns
 // true for success.
 bool Move(const FilePath& from_path, const FilePath& to_path);
-// Deprecated temporary compatibility function.
-bool Move(const std::wstring& from_path, const std::wstring& to_path);
+
+// Renames file |from_path| to |to_path|. Both paths must be on the same
+// volume, or the function will fail. Destination file will be created
+// if it doesn't exist. Prefer this function over Move when dealing with
+// temporary files. On Windows it preserves attributes of the target file.
+// Returns true on success.
+bool ReplaceFile(const FilePath& from_path, const FilePath& to_path);
 
 // Copies a single file. Use CopyDirectory to copy directories.
 bool CopyFile(const FilePath& from_path, const FilePath& to_path);
-// Deprecated temporary compatibility function.
-bool CopyFile(const std::wstring& from_path, const std::wstring& to_path);
 
 // Copies the given path, and optionally all subdirectories and their contents
 // as well.
 // If there are files existing under to_path, always overwrite.
 // Returns true if successful, false otherwise.
-// Dont't use wildcards on the names, it may stop working without notice.
+// Don't use wildcards on the names, it may stop working without notice.
 //
 // If you only need to copy a file use CopyFile, it's faster.
 bool CopyDirectory(const FilePath& from_path, const FilePath& to_path,
                    bool recursive);
-// Deprecated temporary compatibility function.
-bool CopyDirectory(const std::wstring& from_path, const std::wstring& to_path,
-                   bool recursive);
 
 // Returns true if the given path exists on the local filesystem,
 // false otherwise.
 bool PathExists(const FilePath& path);
-// Deprecated temporary compatibility function.
-bool PathExists(const std::wstring& path);
 
 // Returns true if the given path is writable by the user, false otherwise.
 bool PathIsWritable(const FilePath& path);
-// Deprecated temporary compatibility function.
-bool PathIsWritable(const std::wstring& path);
 
 // Returns true if the given path exists and is a directory, false otherwise.
 bool DirectoryExists(const FilePath& path);
-// Deprecated temporary compatibility function.
-bool DirectoryExists(const std::wstring& path);
 
 #if defined(OS_WIN)
 // Gets the creation time of the given file (expressed in the local timezone),
 // and returns it via the creation_time parameter.  Returns true if successful,
 // false otherwise.
 bool GetFileCreationLocalTime(const std::wstring& filename,
                               LPSYSTEMTIME creation_time);
 
@@ -207,196 +151,217 @@ bool GetFileCreationLocalTime(const std:
 bool GetFileCreationLocalTimeFromHandle(HANDLE file_handle,
                                         LPSYSTEMTIME creation_time);
 #endif  // defined(OS_WIN)
 
 // Returns true if the contents of the two files given are equal, false
 // otherwise.  If either file can't be read, returns false.
 bool ContentsEqual(const FilePath& filename1,
                    const FilePath& filename2);
-// Deprecated temporary compatibility function.
-bool ContentsEqual(const std::wstring& filename1,
-                   const std::wstring& filename2);
+
+// Returns true if the contents of the two text files given are equal, false
+// otherwise.  This routine treats "\r\n" and "\n" as equivalent.
+bool TextContentsEqual(const FilePath& filename1, const FilePath& filename2);
 
 // Read the file at |path| into |contents|, returning true on success.
 // Useful for unit tests.
 bool ReadFileToString(const FilePath& path, std::string* contents);
-// Deprecated version.
-bool ReadFileToString(const std::wstring& path, std::string* contents);
 
 #if defined(OS_POSIX)
 // Read exactly |bytes| bytes from file descriptor |fd|, storing the result
 // in |buffer|. This function is protected against EINTR and partial reads.
 // Returns true iff |bytes| bytes have been successfuly read from |fd|.
 bool ReadFromFD(int fd, char* buffer, size_t bytes);
 #endif  // defined(OS_POSIX)
 
 #if defined(OS_WIN)
 // Resolve Windows shortcut (.LNK file)
-// Argument path specifies a valid LNK file. On success, return true and put
-// the URL into path. If path is a invalid .LNK file, return false.
+// This methods tries to resolve a shortcut .LNK file. If the |path| is valid
+// returns true and puts the target into the |path|, otherwise returns
+// false leaving the path as it is.
 bool ResolveShortcut(FilePath* path);
-// Deprecated temporary compatibility function.
-bool ResolveShortcut(std::wstring* path);
 
 // Create a Windows shortcut (.LNK file)
 // This method creates a shortcut link using the information given. Ensure
 // you have initialized COM before calling into this function. 'source'
 // and 'destination' parameters are required, everything else can be NULL.
 // 'source' is the existing file, 'destination' is the new link file to be
 // created; for best results pass the filename with the .lnk extension.
 // The 'icon' can specify a dll or exe in which case the icon index is the
-// resource id.
+// resource id. 'app_id' is the app model id for the shortcut on Win7.
 // Note that if the shortcut exists it will overwrite it.
 bool CreateShortcutLink(const wchar_t *source, const wchar_t *destination,
                         const wchar_t *working_dir, const wchar_t *arguments,
                         const wchar_t *description, const wchar_t *icon,
-                        int icon_index);
+                        int icon_index, const wchar_t* app_id);
 
 // Update a Windows shortcut (.LNK file). This method assumes the shortcut
 // link already exists (otherwise false is returned). Ensure you have
 // initialized COM before calling into this function. Only 'destination'
 // parameter is required, everything else can be NULL (but if everything else
 // is NULL no changes are made to the shortcut). 'destination' is the link
-// file to be updated. For best results pass the filename with the .lnk
-// extension.
+// file to be updated. 'app_id' is the app model id for the shortcut on Win7.
+// For best results pass the filename with the .lnk extension.
 bool UpdateShortcutLink(const wchar_t *source, const wchar_t *destination,
                         const wchar_t *working_dir, const wchar_t *arguments,
                         const wchar_t *description, const wchar_t *icon,
-                        int icon_index);
+                        int icon_index, const wchar_t* app_id);
+
+// Pins a shortcut to the Windows 7 taskbar. The shortcut file must already
+// exist and be a shortcut that points to an executable.
+bool TaskbarPinShortcutLink(const wchar_t* shortcut);
+
+// Unpins a shortcut from the Windows 7 taskbar. The shortcut must exist and
+// already be pinned to the taskbar.
+bool TaskbarUnpinShortcutLink(const wchar_t* shortcut);
 
 // Return true if the given directory is empty
 bool IsDirectoryEmpty(const std::wstring& dir_path);
 
 // Copy from_path to to_path recursively and then delete from_path recursively.
 // Returns true if all operations succeed.
 // This function simulates Move(), but unlike Move() it works across volumes.
 // This fuction is not transactional.
 bool CopyAndDeleteDirectory(const FilePath& from_path,
                             const FilePath& to_path);
 #endif
 
 // Get the temporary directory provided by the system.
 bool GetTempDir(FilePath* path);
-// Deprecated temporary compatibility function.
-bool GetTempDir(std::wstring* path);
 // Get a temporary directory for shared memory files.
 // Only useful on POSIX; redirects to GetTempDir() on Windows.
 bool GetShmemTempDir(FilePath* path);
 
+// Get the home directory.  This is more complicated than just getenv("HOME")
+// as it knows to fall back on getpwent() etc.
+FilePath GetHomeDir();
+
 // Creates a temporary file. The full path is placed in |path|, and the
 // function returns true if was successful in creating the file. The file will
 // be empty and all handles closed after this function returns.
-// TODO(erikkay): rename this function and track down all of the callers.
-// (Clarification of erik's comment: the intent is to rename the BlahFileName()
-//  calls into BlahFile(), since they create temp files (not temp filenames).)
-bool CreateTemporaryFileName(FilePath* path);
-// Deprecated temporary compatibility function.
-bool CreateTemporaryFileName(std::wstring* temp_file);
+bool CreateTemporaryFile(FilePath* path);
 
 // Create and open a temporary file.  File is opened for read/write.
 // The full path is placed in |path|, and the function returns true if
 // was successful in creating and opening the file.
 FILE* CreateAndOpenTemporaryFile(FilePath* path);
 // Like above but for shmem files.  Only useful for POSIX.
 FILE* CreateAndOpenTemporaryShmemFile(FilePath* path);
 
 // Similar to CreateAndOpenTemporaryFile, but the file is created in |dir|.
 FILE* CreateAndOpenTemporaryFileInDir(const FilePath& dir, FilePath* path);
 
-// Same as CreateTemporaryFileName but the file is created in |dir|.
-bool CreateTemporaryFileNameInDir(const std::wstring& dir,
-                                  std::wstring* temp_file);
+// Same as CreateTemporaryFile but the file is created in |dir|.
+bool CreateTemporaryFileInDir(const FilePath& dir,
+                              FilePath* temp_file);
+
+// Create a directory within another directory.
+// Extra characters will be appended to |name_tmpl| to ensure that the
+// new directory does not have the same name as an existing directory.
+bool CreateTemporaryDirInDir(const FilePath& base_dir,
+                             const FilePath::StringType& prefix,
+                             FilePath* new_dir);
 
 // Create a new directory under TempPath. If prefix is provided, the new
 // directory name is in the format of prefixyyyy.
 // NOTE: prefix is ignored in the POSIX implementation.
 // TODO(erikkay): is this OK?
 // If success, return true and output the full path of the directory created.
 bool CreateNewTempDirectory(const FilePath::StringType& prefix,
                             FilePath* new_temp_path);
-// Deprecated temporary compatibility function.
-bool CreateNewTempDirectory(const std::wstring& prefix,
-                            std::wstring* new_temp_path);
 
 // Creates a directory, as well as creating any parent directories, if they
 // don't exist. Returns 'true' on successful creation, or if the directory
-// already exists.
+// already exists.  The directory is only readable by the current user.
 bool CreateDirectory(const FilePath& full_path);
-// Deprecated temporary compatibility function.
-bool CreateDirectory(const std::wstring& full_path);
 
 // Returns the file size. Returns true on success.
 bool GetFileSize(const FilePath& file_path, int64_t* file_size);
 // Deprecated temporary compatibility function.
 bool GetFileSize(const std::wstring& file_path, int64_t* file_size);
 
 // Used to hold information about a given file path.  See GetFileInfo below.
 struct FileInfo {
   // The size of the file in bytes.  Undefined when is_directory is true.
   int64_t size;
 
   // True if the file corresponds to a directory.
   bool is_directory;
 
+  // The last modified time of a file.
+  base::Time last_modified;
+
   // Add additional fields here as needed.
 };
 
 // Returns information about the given file path.
 bool GetFileInfo(const FilePath& file_path, FileInfo* info);
-// Deprecated temporary compatibility function.
-bool GetFileInfo(const std::wstring& file_path, FileInfo* info);
+
+// Set the time of the last modification. Useful for unit tests.
+bool SetLastModifiedTime(const FilePath& file_path, base::Time last_modified);
+
+#if defined(OS_POSIX)
+// Store inode number of |path| in |inode|. Return true on success.
+bool GetInode(const FilePath& path, ino_t* inode);
+#endif
 
 // Wrapper for fopen-like calls. Returns non-NULL FILE* on success.
 FILE* OpenFile(const FilePath& filename, const char* mode);
-// Deprecated temporary compatibility functions.
-FILE* OpenFile(const std::string& filename, const char* mode);
-FILE* OpenFile(const std::wstring& filename, const char* mode);
 
 // Closes file opened by OpenFile. Returns true on success.
 bool CloseFile(FILE* file);
 
 // Truncates an open file to end at the location of the current file pointer.
 // This is a cross-platform analog to Windows' SetEndOfFile() function.
 bool TruncateFile(FILE* file);
 
 // Reads the given number of bytes from the file into the buffer.  Returns
 // the number of read bytes, or -1 on error.
 int ReadFile(const FilePath& filename, char* data, int size);
-// Deprecated temporary compatibility function.
-int ReadFile(const std::wstring& filename, char* data, int size);
 
 // Writes the given buffer into the file, overwriting any data that was
 // previously there.  Returns the number of bytes written, or -1 on error.
 int WriteFile(const FilePath& filename, const char* data, int size);
-// Deprecated temporary compatibility function.
-int WriteFile(const std::wstring& filename, const char* data, int size);
+#if defined(OS_POSIX)
+// Append the data to |fd|. Does not close |fd| when done.
+int WriteFileDescriptor(const int fd, const char* data, int size);
+#endif
 
 // Gets the current working directory for the process.
 bool GetCurrentDirectory(FilePath* path);
-// Deprecated temporary compatibility function.
-bool GetCurrentDirectory(std::wstring* path);
 
 // Sets the current working directory for the process.
 bool SetCurrentDirectory(const FilePath& path);
-// Deprecated temporary compatibility function.
-bool SetCurrentDirectory(const std::wstring& current_directory);
 
 // A class to handle auto-closing of FILE*'s.
 class ScopedFILEClose {
  public:
   inline void operator()(FILE* x) const {
     if (x) {
       fclose(x);
     }
   }
 };
 
 typedef scoped_ptr_malloc<FILE, ScopedFILEClose> ScopedFILE;
 
+#if defined(OS_POSIX)
+// A class to handle auto-closing of FDs.
+class ScopedFDClose {
+ public:
+  inline void operator()(int* x) const {
+    if (x && *x >= 0) {
+      HANDLE_EINTR(close(*x));
+    }
+  }
+};
+
+typedef scoped_ptr_malloc<int, ScopedFDClose> ScopedFD;
+#endif  // OS_POSIX
+
 // A class for enumerating the files in a provided path. The order of the
 // results is not guaranteed.
 //
 // DO NOT USE FROM THE MAIN THREAD of your application unless it is a test
 // program where latency does not matter. This class is blocking.
 class FileEnumerator {
  public:
 #if defined(OS_WIN)
@@ -404,19 +369,22 @@ class FileEnumerator {
 #elif defined(OS_POSIX)
   typedef struct {
     struct stat stat;
     std::string filename;
   } FindInfo;
 #endif
 
   enum FILE_TYPE {
-    FILES                 = 0x1,
-    DIRECTORIES           = 0x2,
-    FILES_AND_DIRECTORIES = 0x3
+    FILES                 = 1 << 0,
+    DIRECTORIES           = 1 << 1,
+    INCLUDE_DOT_DOT       = 1 << 2,
+#if defined(OS_POSIX)
+    SHOW_SYM_LINKS        = 1 << 4,
+#endif
   };
 
   // |root_path| is the starting directory to search for. It may or may not end
   // in a slash.
   //
   // If |recursive| is true, this will enumerate all matches in any
   // subdirectories matched as well. It does a breadth-first search, so all
   // files in one directory will be returned before any files in a
@@ -444,84 +412,166 @@ class FileEnumerator {
   ~FileEnumerator();
 
   // Returns an empty string if there are no more results.
   FilePath Next();
 
   // Write the file info into |info|.
   void GetFindInfo(FindInfo* info);
 
+  // Looks inside a FindInfo and determines if it's a directory.
+  static bool IsDirectory(const FindInfo& info);
+
+  static FilePath GetFilename(const FindInfo& find_info);
+
  private:
+  // Returns true if the given path should be skipped in enumeration.
+  bool ShouldSkip(const FilePath& path);
+
+
+#if defined(OS_WIN)
+  WIN32_FIND_DATA find_data_;
+  HANDLE find_handle_;
+#elif defined(OS_POSIX)
+  typedef struct {
+    FilePath filename;
+    struct stat stat;
+  } DirectoryEntryInfo;
+
+  // Read the filenames in source into the vector of DirectoryEntryInfo's
+  static bool ReadDirectory(std::vector<DirectoryEntryInfo>* entries,
+                            const FilePath& source, bool show_links);
+
+  // The files in the current directory
+  std::vector<DirectoryEntryInfo> directory_entries_;
+
+  // The next entry to use from the directory_entries_ vector
+  size_t current_directory_entry_;
+#endif
+
   FilePath root_path_;
   bool recursive_;
   FILE_TYPE file_type_;
-  FilePath pattern_;  // Empty when we want to find everything.
+  FilePath::StringType pattern_;  // Empty when we want to find everything.
 
   // Set to true when there is a find operation open. This way, we can lazily
   // start the operations when the caller calls Next().
   bool is_in_find_op_;
 
   // A stack that keeps track of which subdirectories we still need to
   // enumerate in the breadth-first search.
   std::stack<FilePath> pending_paths_;
 
-#if defined(OS_WIN)
-  WIN32_FIND_DATA find_data_;
-  HANDLE find_handle_;
-#elif defined(ANDROID)
-  void *fts_;
-#elif defined(OS_POSIX)
-  FTS* fts_;
-  FTSENT* fts_ent_;
-#endif
-
-  DISALLOW_EVIL_CONSTRUCTORS(FileEnumerator);
+  DISALLOW_COPY_AND_ASSIGN(FileEnumerator);
 };
 
 class MemoryMappedFile {
  public:
   // The default constructor sets all members to invalid/null values.
   MemoryMappedFile();
   ~MemoryMappedFile();
 
   // Opens an existing file and maps it into memory. Access is restricted to
   // read only. If this object already points to a valid memory mapped file
   // then this method will fail and return false. If it cannot open the file,
   // the file does not exist, or the memory mapping fails, it will return false.
   // Later we may want to allow the user to specify access.
   bool Initialize(const FilePath& file_name);
+  // As above, but works with an already-opened file. MemoryMappedFile will take
+  // ownership of |file| and close it when done.
+  bool Initialize(base::PlatformFile file);
 
   const uint8_t* data() const { return data_; }
   size_t length() const { return length_; }
 
   // Is file_ a valid file handle that points to an open, memory mapped file?
   bool IsValid();
 
  private:
+  // Open the given file and pass it to MapFileToMemoryInternal().
+  bool MapFileToMemory(const FilePath& file_name);
+
   // Map the file to memory, set data_ to that memory address. Return true on
   // success, false on any kind of failure. This is a helper for Initialize().
-  bool MapFileToMemory(const FilePath& file_name);
+  bool MapFileToMemoryInternal();
 
   // Closes all open handles. Later we may want to make this public.
   void CloseHandles();
 
+  base::PlatformFile file_;
 #if defined(OS_WIN)
-  HANDLE file_;
   HANDLE file_mapping_;
-#elif defined(OS_POSIX)
-  // The file descriptor.
-  int file_;
 #endif
   uint8_t* data_;
   size_t length_;
 
   DISALLOW_COPY_AND_ASSIGN(MemoryMappedFile);
 };
 
 // Renames a file using the SHFileOperation API to ensure that the target file
 // gets the correct default security descriptor in the new path.
 bool RenameFileAndResetSecurityDescriptor(
     const FilePath& source_file_path,
     const FilePath& target_file_path);
 
+// Returns whether the file has been modified since a particular date.
+bool HasFileBeenModifiedSince(const FileEnumerator::FindInfo& find_info,
+                              const base::Time& cutoff_time);
+
+#ifdef UNIT_TEST
+
+inline bool MakeFileUnreadable(const FilePath& path) {
+#if defined(OS_POSIX)
+  struct stat stat_buf;
+  if (stat(path.value().c_str(), &stat_buf) != 0)
+    return false;
+  stat_buf.st_mode &= ~(S_IRUSR | S_IRGRP | S_IROTH);
+
+  return chmod(path.value().c_str(), stat_buf.st_mode) == 0;
+
+#elif defined(OS_WIN)
+  PACL old_dacl;
+  PSECURITY_DESCRIPTOR security_descriptor;
+  if (GetNamedSecurityInfo(const_cast<wchar_t*>(path.value().c_str()),
+                           SE_FILE_OBJECT,
+                           DACL_SECURITY_INFORMATION, NULL, NULL, &old_dacl,
+                           NULL, &security_descriptor) != ERROR_SUCCESS)
+    return false;
+
+  // Deny Read access for the current user.
+  EXPLICIT_ACCESS change;
+  change.grfAccessPermissions = GENERIC_READ;
+  change.grfAccessMode = DENY_ACCESS;
+  change.grfInheritance = 0;
+  change.Trustee.pMultipleTrustee = NULL;
+  change.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
+  change.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
+  change.Trustee.TrusteeType = TRUSTEE_IS_USER;
+  change.Trustee.ptstrName = L"CURRENT_USER";
+
+  PACL new_dacl;
+  if (SetEntriesInAcl(1, &change, old_dacl, &new_dacl) != ERROR_SUCCESS) {
+    LocalFree(security_descriptor);
+    return false;
+  }
+
+  DWORD rc = SetNamedSecurityInfo(const_cast<wchar_t*>(path.value().c_str()),
+                                  SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
+                                  NULL, NULL, new_dacl, NULL);
+  LocalFree(security_descriptor);
+  LocalFree(new_dacl);
+
+  return rc == ERROR_SUCCESS;
+#else
+  NOTIMPLEMENTED();
+  return false;
+#endif
+}
+
+#endif  // UNIT_TEST
+
 }  // namespace file_util
 
+// Deprecated functions have been moved to this separate header file,
+// which must be included last after all the above definitions.
+#include "base/file_util_deprecated.h"
+
 #endif  // BASE_FILE_UTIL_H_
diff --git a/ipc/chromium/src/base/hash_tables.h b/ipc/chromium/src/base/hash_tables.h
index c2dcde5..1edd667 100644
--- a/ipc/chromium/src/base/hash_tables.h
+++ b/ipc/chromium/src/base/hash_tables.h
@@ -31,6 +31,15 @@
 using stdext::hash_set;
 #endif
 }
+#elif defined(COMPILER_SUNPRO)
+#include <map>
+#include <set>
+namespace base {
+using std::map;
+using std::set;
+}
+#define hash_map map
+#define hash_set set
 #elif defined(COMPILER_GCC)
 // This is a hack to disable the gcc 4.4 warning about hash_map and hash_set
 // being deprecated.  We can get rid of this when we upgrade to VS2008 and we
diff --git a/ipc/chromium/src/base/process_util_posix.cc b/ipc/chromium/src/base/process_util_posix.cc
--- a/ipc/chromium/src/base/process_util_posix.cc
+++ b/ipc/chromium/src/base/process_util_posix.cc
@@ -110,7 +110,7 @@
 #if defined(ANDROID)
   static const rlim_t kSystemDefaultMaxFds = 1024;
   static const char kFDDir[] = "/proc/self/fd";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
   static const rlim_t kSystemDefaultMaxFds = 8192;
   static const char kFDDir[] = "/proc/self/fd";
 #elif defined(OS_MACOSX)
@@ -202,7 +202,7 @@
 // TODO(agl): Remove this function. It's fundamentally broken for multithreaded
 // apps.
 void SetAllFDsToCloseOnExec() {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
   const char fd_dir[] = "/proc/self/fd";
 #elif defined(OS_MACOSX) || defined(OS_BSD)
   const char fd_dir[] = "/dev/fd";
diff --git a/ipc/chromium/src/chrome/common/transport_dib.h b/ipc/chromium/src/chrome/common/transport_dib.h
--- a/ipc/chromium/src/chrome/common/transport_dib.h
+++ b/ipc/chromium/src/chrome/common/transport_dib.h
@@ -13,7 +13,7 @@
 
 #if defined(OS_WIN)
 #include <windows.h>
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
 #include "chrome/common/x11_util.h"
 #endif
 
@@ -70,7 +70,7 @@
   typedef base::SharedMemoryHandle Handle;
   // On Mac, the inode number of the backing file is used as an id.
   typedef base::SharedMemoryId Id;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
   typedef int Handle;  // These two ints are SysV IPC shared memory keys
   typedef int Id;
 #endif
@@ -100,7 +100,7 @@
   // wire to give this transport DIB to another process.
   Handle handle() const;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
   // Map the shared memory into the X server and return an id for the shared
   // segment.
   XID MapToX(Display* connection);
@@ -111,7 +111,7 @@
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_BSD)
   explicit TransportDIB(base::SharedMemoryHandle dib);
   base::SharedMemory shared_memory_;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_SOLARIS)
   int key_;  // SysV shared memory id
   void* address_;  // mapped address
   XID x_shm_;  // X id for the shared segment
diff --git a/ipc/chromium/src/base/file_util_posix.cc b/ipc/chromium/src/base/file_util_posix.cc
--- a/ipc/chromium/src/base/file_util_posix.cc
+++ b/ipc/chromium/src/base/file_util_posix.cc
@@ -1,4 +1,4 @@
-// Copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
@@ -8,20 +8,25 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <fnmatch.h>
-#ifndef ANDROID
-#include <fts.h>
-#endif
 #include <libgen.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <sys/errno.h>
 #include <sys/mman.h>
 #define _DARWIN_USE_64_BIT_INODE // Use 64-bit inode data structures
 #include <sys/stat.h>
+#include <sys/time.h>
 #include <sys/types.h>
 #include <time.h>
 #include <unistd.h>
 
+#if defined(OS_MACOSX)
+#include <AvailabilityMacros.h>
+#else
+#include <glib.h>
+#endif
+
 #include <fstream>
 #include <string>
 #include <vector>
@@ -29,18 +34,37 @@
 #include "base/basictypes.h"
 #include "base/eintr_wrapper.h"
 #include "base/file_path.h"
+#include "base/lock.h"
 #include "base/logging.h"
+#include "base/scoped_ptr.h"
+#include "base/singleton.h"
 #include "base/string_util.h"
+#include "base/sys_string_conversions.h"
 #include "base/time.h"
 
 namespace file_util {
 
+#if defined(OS_OPENBSD) || defined(OS_FREEBSD) || \
+    (defined(OS_MACOSX) && \
+     MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5)
+typedef struct stat stat_wrapper_t;
+static int CallStat(const char *path, stat_wrapper_t *sb) {
+  return stat(path, sb);
+}
+#else
+typedef struct stat64 stat_wrapper_t;
+static int CallStat(const char *path, stat_wrapper_t *sb) {
+  return stat64(path, sb);
+}
+#endif
+
 #if defined(GOOGLE_CHROME_BUILD)
 static const char* kTempFileName = "com.google.chrome.XXXXXX";
 #else
 static const char* kTempFileName = "org.chromium.XXXXXX";
 #endif
 
+#ifndef OS_SOLARIS
 std::wstring GetDirectoryFromPath(const std::wstring& path) {
   if (EndsWithSeparator(path)) {
     std::wstring dir = path;
@@ -52,6 +76,7 @@
     return UTF8ToWide(dirname(full_path));
   }
 }
+#endif
 
 bool AbsolutePath(FilePath* path) {
   char full_path[PATH_MAX];
@@ -67,9 +92,22 @@
 
   DIR* dir = opendir(path.value().c_str());
   if (dir) {
+#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_FREEBSD) && \
+    !defined(OS_OPENBSD) && !defined(OS_SOLARIS)
+  #error Port warning: depending on the definition of struct dirent, \
+         additional space for pathname may be needed
+#endif
+
+#ifdef OS_SOLARIS    
+    struct {
+            dirent dent_buffer;
+            char chars[MAXNAMLEN];
+    } ent_buf;
+#else  
     struct dirent ent_buf;
+#endif  
     struct dirent* ent;
-    while (readdir_r(dir, &ent_buf, &ent) == 0 && ent) {
+    while (readdir_r(dir, (dirent *)&ent_buf, &ent) == 0 && ent) {
       if ((strcmp(ent->d_name, ".") == 0) ||
           (strcmp(ent->d_name, "..") == 0))
         continue;
@@ -121,53 +159,46 @@
   if (!recursive)
     return (rmdir(path_str) == 0);
 
-#ifdef ANDROID
-  // XXX Need ftsless impl for bionic
-  return false;
-#else
   bool success = true;
-  int ftsflags = FTS_PHYSICAL | FTS_NOSTAT;
-  char top_dir[PATH_MAX];
-  if (base::strlcpy(top_dir, path_str,
-                    arraysize(top_dir)) >= arraysize(top_dir)) {
-    return false;
+  std::stack<std::string> directories;
+  directories.push(path.value());
+  FileEnumerator traversal(path, true, static_cast<FileEnumerator::FILE_TYPE>(
+        FileEnumerator::FILES | FileEnumerator::DIRECTORIES |
+        FileEnumerator::SHOW_SYM_LINKS));
+  for (FilePath current = traversal.Next(); success && !current.empty();
+       current = traversal.Next()) {
+    FileEnumerator::FindInfo info;
+    traversal.GetFindInfo(&info);
+
+    if (S_ISDIR(info.stat.st_mode))
+      directories.push(current.value());
+    else
+      success = (unlink(current.value().c_str()) == 0);
   }
-  char* dir_list[2] = { top_dir, NULL };
-  FTS* fts = fts_open(dir_list, ftsflags, NULL);
-  if (fts) {
-    FTSENT* fts_ent = fts_read(fts);
-    while (success && fts_ent != NULL) {
-      switch (fts_ent->fts_info) {
-        case FTS_DNR:
-        case FTS_ERR:
-          // log error
-          success = false;
-          continue;
-          break;
-        case FTS_DP:
-          success = (rmdir(fts_ent->fts_accpath) == 0);
-          break;
-        case FTS_D:
-          break;
-        case FTS_NSOK:
-        case FTS_F:
-        case FTS_SL:
-        case FTS_SLNONE:
-          success = (unlink(fts_ent->fts_accpath) == 0);
-          break;
-        default:
-          DCHECK(false);
-          break;
-      }
-      fts_ent = fts_read(fts);
-    }
-    fts_close(fts);
+
+  while (success && !directories.empty()) {
+    FilePath dir = FilePath(directories.top());
+    directories.pop();
+    success = (rmdir(dir.value().c_str()) == 0);
   }
+
   return success;
-#endif
 }
 
 bool Move(const FilePath& from_path, const FilePath& to_path) {
+  // Windows compatibility: if to_path exists, from_path and to_path
+  // must be the same type, either both files, or both directories.
+  stat_wrapper_t to_file_info;
+  if (CallStat(to_path.value().c_str(), &to_file_info) == 0) {
+    stat_wrapper_t from_file_info;
+    if (CallStat(from_path.value().c_str(), &from_file_info) == 0) {
+      if (S_ISDIR(to_file_info.st_mode) != S_ISDIR(from_file_info.st_mode))
+        return false;
+    } else {
+      return false;
+    }
+  }
+
   if (rename(from_path.value().c_str(), to_path.value().c_str()) == 0)
     return true;
 
@@ -178,6 +209,10 @@
   return true;
 }
 
+bool ReplaceFile(const FilePath& from_path, const FilePath& to_path) {
+  return (rename(from_path.value().c_str(), to_path.value().c_str()) == 0);
+}
+
 bool CopyDirectory(const FilePath& from_path,
                    const FilePath& to_path,
                    bool recursive) {
@@ -194,98 +229,89 @@
     return false;
   }
 
-#ifdef ANDROID
-  // XXX Need ftsless impl for bionic
-  return false;
-#else
-  char* dir_list[] = { top_dir, NULL };
-  FTS* fts = fts_open(dir_list, FTS_PHYSICAL | FTS_NOSTAT, NULL);
-  if (!fts) {
-    LOG(ERROR) << "fts_open failed: " << strerror(errno);
+  // This function does not properly handle destinations within the source
+  FilePath real_to_path = to_path;
+  if (PathExists(real_to_path)) {
+    if (!AbsolutePath(&real_to_path))
+      return false;
+  } else {
+    real_to_path = real_to_path.DirName();
+    if (!AbsolutePath(&real_to_path))
+      return false;
+  }
+  FilePath real_from_path = from_path;
+  if (!AbsolutePath(&real_from_path))
     return false;
+  if (real_to_path.value().size() >= real_from_path.value().size() &&
+      real_to_path.value().compare(0, real_from_path.value().size(),
+      real_from_path.value()) == 0)
+    return false;
+
+  bool success = true;
+  FileEnumerator::FILE_TYPE traverse_type =
+      static_cast<FileEnumerator::FILE_TYPE>(FileEnumerator::FILES |
+      FileEnumerator::SHOW_SYM_LINKS);
+  if (recursive)
+    traverse_type = static_cast<FileEnumerator::FILE_TYPE>(
+        traverse_type | FileEnumerator::DIRECTORIES);
+  FileEnumerator traversal(from_path, recursive, traverse_type);
+
+  // We have to mimic windows behavior here. |to_path| may not exist yet,
+  // start the loop with |to_path|.
+  FileEnumerator::FindInfo info;
+  FilePath current = from_path;
+  if (stat(from_path.value().c_str(), &info.stat) < 0) {
+    LOG(ERROR) << "CopyDirectory() couldn't stat source directory: " <<
+        from_path.value() << " errno = " << errno;
+    success = false;
+  }
+  struct stat to_path_stat;
+  FilePath from_path_base = from_path;
+  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
+      S_ISDIR(to_path_stat.st_mode)) {
+    // If the destination already exists and is a directory, then the
+    // top level of source needs to be copied.
+    from_path_base = from_path.DirName();
   }
 
-  int error = 0;
-  FTSENT* ent;
-  while (!error && (ent = fts_read(fts)) != NULL) {
-    // ent->fts_path is the source path, including from_path, so paste
+  // The Windows version of this function assumes that non-recursive calls
+  // will always have a directory for from_path.
+  DCHECK(recursive || S_ISDIR(info.stat.st_mode));
+
+  while (success && !current.empty()) {
+    // current is the source path, including from_path, so paste
     // the suffix after from_path onto to_path to create the target_path.
-    std::string suffix(&ent->fts_path[from_path.value().size()]);
+    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
     // Strip the leading '/' (if any).
     if (!suffix.empty()) {
       DCHECK_EQ('/', suffix[0]);
       suffix.erase(0, 1);
     }
     const FilePath target_path = to_path.Append(suffix);
-    switch (ent->fts_info) {
-      case FTS_D:  // Preorder directory.
-        // If we encounter a subdirectory in a non-recursive copy, prune it
-        // from the traversal.
-        if (!recursive && ent->fts_level > 0) {
-          if (fts_set(fts, ent, FTS_SKIP) != 0)
-            error = errno;
-          continue;
-        }
 
-        // Try creating the target dir, continuing on it if it exists already.
-        // Rely on the user's umask to produce correct permissions.
-        if (mkdir(target_path.value().c_str(), 0777) != 0) {
-          if (errno != EEXIST)
-            error = errno;
-        }
-        break;
-      case FTS_F:     // Regular file.
-      case FTS_NSOK:  // File, no stat info requested.
-        errno = 0;
-        if (!CopyFile(FilePath(ent->fts_path), target_path))
-          error = errno ? errno : EINVAL;
-        break;
-      case FTS_DP:   // Postorder directory.
-      case FTS_DOT:  // "." or ".."
-        // Skip it.
-        continue;
-      case FTS_DC:   // Directory causing a cycle.
-        // Skip this branch.
-        if (fts_set(fts, ent, FTS_SKIP) != 0)
-          error = errno;
-        break;
-      case FTS_DNR:  // Directory cannot be read.
-      case FTS_ERR:  // Error.
-      case FTS_NS:   // Stat failed.
-        // Abort with the error.
-        error = ent->fts_errno;
-        break;
-      case FTS_SL:      // Symlink.
-      case FTS_SLNONE:  // Symlink with broken target.
-        LOG(WARNING) << "CopyDirectory() skipping symbolic link: " <<
-            ent->fts_path;
-        continue;
-      case FTS_DEFAULT:  // Some other sort of file.
-        LOG(WARNING) << "CopyDirectory() skipping file of unknown type: " <<
-            ent->fts_path;
-        continue;
-      default:
-        NOTREACHED();
-        continue;  // Hope for the best!
+    if (S_ISDIR(info.stat.st_mode)) {
+      if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
+          errno != EEXIST) {
+        LOG(ERROR) << "CopyDirectory() couldn't create directory: " <<
+            target_path.value() << " errno = " << errno;
+        success = false;
+      }
+    } else if (S_ISREG(info.stat.st_mode)) {
+      if (!CopyFile(current, target_path)) {
+        LOG(ERROR) << "CopyDirectory() couldn't create file: " <<
+            target_path.value();
+        success = false;
+      }
+    } else {
+      LOG(WARNING) << "CopyDirectory() skipping non-regular file: " <<
+          current.value();
     }
-  }
-  // fts_read may have returned NULL and set errno to indicate an error.
-  if (!error && errno != 0)
-    error = errno;
 
-  if (!fts_close(fts)) {
-    // If we already have an error, let's use that error instead of the error
-    // fts_close set.
-    if (!error)
-      error = errno;
+    current = traversal.Next();
+    traversal.GetFindInfo(&info);
   }
 
-  if (error) {
-    LOG(ERROR) << "CopyDirectory(): " << strerror(error);
-    return false;
-  }
-  return true;
-#endif
+  return success;
 }
 
 bool PathExists(const FilePath& path) {
@@ -361,10 +387,8 @@
 }
 
 // Creates and opens a temporary file in |directory|, returning the
-// file descriptor.  |path| is set to the temporary file path.
-// Note TODO(erikkay) comment in header for BlahFileName() calls; the
-// intent is to rename these files BlahFile() (since they create
-// files, not filenames).  This function does NOT unlink() the file.
+// file descriptor. |path| is set to the temporary file path.
+// This function does NOT unlink() the file.
 int CreateAndOpenFdForTemporaryFile(FilePath directory, FilePath* path) {
   *path = directory.Append(kTempFileName);
   const std::string& tmpdir_string = path->value();
@@ -374,7 +398,7 @@
   return mkstemp(buffer);
 }
 
-bool CreateTemporaryFileName(FilePath* path) {
+bool CreateTemporaryFile(FilePath* path) {
   FilePath directory;
   if (!GetTempDir(&directory))
     return false;
@@ -401,11 +425,35 @@
   return fdopen(fd, "a+");
 }
 
-bool CreateTemporaryFileNameInDir(const std::wstring& dir,
-                                  std::wstring* temp_file) {
-  // Not implemented yet.
-  NOTREACHED();
-  return false;
+bool CreateTemporaryFileInDir(const FilePath& dir, FilePath* temp_file) {
+  int fd = CreateAndOpenFdForTemporaryFile(dir, temp_file);
+  return ((fd >= 0) && !close(fd));
+}
+
+static bool CreateTemporaryDirInDirImpl(const FilePath& base_dir,
+                                        const FilePath::StringType& name_tmpl,
+                                        FilePath* new_dir) {
+  CHECK(name_tmpl.find("XXXXXX") != FilePath::StringType::npos)
+    << "Directory name template must contain \"XXXXXX\".";
+
+  FilePath sub_dir = base_dir.Append(name_tmpl);
+  std::string sub_dir_string = sub_dir.value();
+
+  // this should be OK since mkdtemp just replaces characters in place
+  char* buffer = const_cast<char*>(sub_dir_string.c_str());
+  char* dtemp = mkdtemp(buffer);
+  if (!dtemp)
+    return false;
+  *new_dir = FilePath(dtemp);
+  return true;
+}
+
+bool CreateTemporaryDirInDir(const FilePath& base_dir,
+                             const FilePath::StringType& prefix,
+                             FilePath* new_dir) {
+  FilePath::StringType mkdtemp_template = prefix;
+  mkdtemp_template.append(FILE_PATH_LITERAL("XXXXXX"));
+  return CreateTemporaryDirInDirImpl(base_dir, mkdtemp_template, new_dir);
 }
 
 bool CreateNewTempDirectory(const FilePath::StringType& prefix,
@@ -413,19 +461,8 @@
   FilePath tmpdir;
   if (!GetTempDir(&tmpdir))
     return false;
-  tmpdir = tmpdir.Append(kTempFileName);
-  std::string tmpdir_string = tmpdir.value();
-#ifdef ANDROID
-  char* dtemp = NULL;
-#else
-  // this should be OK since mkdtemp just replaces characters in place
-  char* buffer = const_cast<char*>(tmpdir_string.c_str());
-  char* dtemp = mkdtemp(buffer);
-#endif
-  if (!dtemp)
-    return false;
-  *new_temp_path = FilePath(dtemp);
-  return true;
+
+  return CreateTemporaryDirInDirImpl(tmpdir, kTempFileName, new_temp_path);
 }
 
 bool CreateDirectory(const FilePath& full_path) {
@@ -443,10 +480,16 @@
   // Iterate through the parents and create the missing ones.
   for (std::vector<FilePath>::reverse_iterator i = subpaths.rbegin();
        i != subpaths.rend(); ++i) {
-    if (!DirectoryExists(*i)) {
-      if (mkdir(i->value().c_str(), 0777) != 0)
-        return false;
-    }
+    if (DirectoryExists(*i))
+      continue;
+    if (mkdir(i->value().c_str(), 0700) == 0)
+      continue;
+    // Mkdir failed, but it might have failed with EEXIST, or some other error
+    // due to the the directory appearing out of thin air. This can occur if
+    // two processes are trying to create the same file system tree at the same
+    // time. Check to see if it exists and make sure it is a directory.
+    if (!DirectoryExists(*i))
+      return false;
   }
   return true;
 }
@@ -457,6 +500,24 @@
     return false;
   results->is_directory = S_ISDIR(file_info.st_mode);
   results->size = file_info.st_size;
+  results->last_modified = base::Time::FromTimeT(file_info.st_mtime);
+  return true;
+}
+
+bool SetLastModifiedTime(const FilePath& file_path, base::Time last_modified) {
+  struct timeval times[2];
+  times[0] = last_modified.ToTimeVal();
+  times[1] = last_modified.ToTimeVal();
+  return (utimes(file_path.value().c_str(), times) == 0);
+}
+
+bool GetInode(const FilePath& path, ino_t* inode) {
+  struct stat buffer;
+  int result = stat(path.value().c_str(), &buffer);
+  if (result < 0)
+    return false;
+
+  *inode = buffer.st_ino;
   return true;
 }
 
@@ -473,9 +534,10 @@
   if (fd < 0)
     return -1;
 
-  int ret_value = HANDLE_EINTR(read(fd, data, size));
-  HANDLE_EINTR(close(fd));
-  return ret_value;
+  ssize_t bytes_read = HANDLE_EINTR(read(fd, data, size));
+  if (int ret = HANDLE_EINTR(close(fd)) < 0)
+    return ret;
+  return bytes_read;
 }
 
 int WriteFile(const FilePath& filename, const char* data, int size) {
@@ -483,20 +545,24 @@
   if (fd < 0)
     return -1;
 
-  // Allow for partial writes
+  int bytes_written = WriteFileDescriptor(fd, data, size);
+  if (int ret = HANDLE_EINTR(close(fd)) < 0)
+    return ret;
+  return bytes_written;
+}
+
+int WriteFileDescriptor(const int fd, const char* data, int size) {
+  // Allow for partial writes.
   ssize_t bytes_written_total = 0;
-  do {
-    ssize_t bytes_written_partial =
-      HANDLE_EINTR(write(fd, data + bytes_written_total,
-                         size - bytes_written_total));
-    if (bytes_written_partial < 0) {
-      HANDLE_EINTR(close(fd));
+  for (ssize_t bytes_written_partial = 0; bytes_written_total < size;
+       bytes_written_total += bytes_written_partial) {
+    bytes_written_partial =
+        HANDLE_EINTR(write(fd, data + bytes_written_total,
+                           size - bytes_written_total));
+    if (bytes_written_partial < 0)
       return -1;
-    }
-    bytes_written_total += bytes_written_partial;
-  } while (bytes_written_total < size);
+  }
 
-  HANDLE_EINTR(close(fd));
   return bytes_written_total;
 }
 
@@ -523,7 +589,11 @@
   if (tmp)
     *path = FilePath(tmp);
   else
+#if defined(OS_SOLARIS)
+    *path = FilePath("/var/tmp");
+#else
     *path = FilePath("/tmp");
+#endif
   return true;
 }
 
@@ -589,10 +659,13 @@
 FileEnumerator::FileEnumerator(const FilePath& root_path,
                                bool recursive,
                                FileEnumerator::FILE_TYPE file_type)
-    : recursive_(recursive),
+    : current_directory_entry_(0),
+      root_path_(root_path),
+      recursive_(recursive),
       file_type_(file_type),
-      is_in_find_op_(false),
-      fts_(NULL) {
+      is_in_find_op_(false) {
+  // INCLUDE_DOT_DOT must not be specified if recursive.
+  DCHECK(!(recursive && (INCLUDE_DOT_DOT & file_type_)));
   pending_paths_.push(root_path);
 }
 
@@ -600,136 +673,190 @@
                                bool recursive,
                                FileEnumerator::FILE_TYPE file_type,
                                const FilePath::StringType& pattern)
-    : recursive_(recursive),
+    : current_directory_entry_(0),
+      root_path_(root_path),
+      recursive_(recursive),
       file_type_(file_type),
-      pattern_(root_path.value()),
-      is_in_find_op_(false),
-      fts_(NULL) {
-  // The Windows version of this code only matches against items in the top-most
-  // directory, and we're comparing fnmatch against full paths, so this is the
-  // easiest way to get the right pattern.
-  pattern_ = pattern_.Append(pattern);
+      pattern_(root_path.Append(pattern).value()),
+      is_in_find_op_(false) {
+  // INCLUDE_DOT_DOT must not be specified if recursive.
+  DCHECK(!(recursive && (INCLUDE_DOT_DOT & file_type_)));
+  // The Windows version of this code appends the pattern to the root_path,
+  // potentially only matching against items in the top-most directory.
+  // Do the same here.
+  if (pattern.size() == 0)
+    pattern_ = FilePath::StringType();
   pending_paths_.push(root_path);
 }
 
 FileEnumerator::~FileEnumerator() {
-#ifndef ANDROID
-  if (fts_)
-    fts_close(fts_);
-#endif
 }
 
 void FileEnumerator::GetFindInfo(FindInfo* info) {
   DCHECK(info);
 
-  if (!is_in_find_op_)
+  if (current_directory_entry_ >= directory_entries_.size())
     return;
 
-#ifndef ANDROID
-  memcpy(&(info->stat), fts_ent_->fts_statp, sizeof(info->stat));
-  info->filename.assign(fts_ent_->fts_name);
-#endif
+  DirectoryEntryInfo* cur_entry = &directory_entries_[current_directory_entry_];
+  memcpy(&(info->stat), &(cur_entry->stat), sizeof(info->stat));
+  info->filename.assign(cur_entry->filename.value());
 }
 
-// As it stands, this method calls itself recursively when the next item of
-// the fts enumeration doesn't match (type, pattern, etc.).  In the case of
-// large directories with many files this can be quite deep.
-// TODO(erikkay) - get rid of this recursive pattern
+bool FileEnumerator::IsDirectory(const FindInfo& info) {
+  return S_ISDIR(info.stat.st_mode);
+}
+
+// static
+FilePath FileEnumerator::GetFilename(const FindInfo& find_info) {
+  return FilePath(find_info.filename);
+}
+
 FilePath FileEnumerator::Next() {
-#ifdef ANDROID
-  return FilePath();
-#else
-  if (!is_in_find_op_) {
+  ++current_directory_entry_;
+
+  // While we've exhausted the entries in the current directory, do the next
+  while (current_directory_entry_ >= directory_entries_.size()) {
     if (pending_paths_.empty())
       return FilePath();
 
-    // The last find FindFirstFile operation is done, prepare a new one.
     root_path_ = pending_paths_.top();
     root_path_ = root_path_.StripTrailingSeparators();
     pending_paths_.pop();
 
-    // Start a new find operation.
-    int ftsflags = FTS_LOGICAL;
-    char top_dir[PATH_MAX];
-    base::strlcpy(top_dir, root_path_.value().c_str(), arraysize(top_dir));
-    char* dir_list[2] = { top_dir, NULL };
-    fts_ = fts_open(dir_list, ftsflags, NULL);
-    if (!fts_)
-      return Next();
-    is_in_find_op_ = true;
-  }
+    std::vector<DirectoryEntryInfo> entries;
+    if (!ReadDirectory(&entries, root_path_, file_type_ & SHOW_SYM_LINKS))
+      continue;
 
-  fts_ent_ = fts_read(fts_);
-  if (fts_ent_ == NULL) {
-    fts_close(fts_);
-    fts_ = NULL;
-    is_in_find_op_ = false;
-    return Next();
-  }
+    directory_entries_.clear();
+    current_directory_entry_ = 0;
+    for (std::vector<DirectoryEntryInfo>::const_iterator
+        i = entries.begin(); i != entries.end(); ++i) {
+      FilePath full_path = root_path_.Append(i->filename);
+      if (ShouldSkip(full_path))
+        continue;
 
-  // Level 0 is the top, which is always skipped.
-  if (fts_ent_->fts_level == 0)
-    return Next();
+      if (pattern_.size() &&
+          fnmatch(pattern_.c_str(), full_path.value().c_str(), FNM_NOESCAPE))
+        continue;
 
-  // Patterns are only matched on the items in the top-most directory.
-  // (see Windows implementation)
-  if (fts_ent_->fts_level == 1 && pattern_.value().length() > 0) {
-    if (fnmatch(pattern_.value().c_str(), fts_ent_->fts_path, 0) != 0) {
-      if (fts_ent_->fts_info == FTS_D)
-        fts_set(fts_, fts_ent_, FTS_SKIP);
-      return Next();
+      if (recursive_ && S_ISDIR(i->stat.st_mode))
+        pending_paths_.push(full_path);
+
+      if ((S_ISDIR(i->stat.st_mode) && (file_type_ & DIRECTORIES)) ||
+          (!S_ISDIR(i->stat.st_mode) && (file_type_ & FILES)))
+        directory_entries_.push_back(*i);
     }
   }
 
-  FilePath cur_file(fts_ent_->fts_path);
-  if (fts_ent_->fts_info == FTS_D) {
-    // If not recursive, then prune children.
-    if (!recursive_)
-      fts_set(fts_, fts_ent_, FTS_SKIP);
-    return (file_type_ & FileEnumerator::DIRECTORIES) ? cur_file : Next();
-  } else if (fts_ent_->fts_info == FTS_F) {
-    return (file_type_ & FileEnumerator::FILES) ? cur_file : Next();
+  return root_path_.Append(directory_entries_[current_directory_entry_
+      ].filename);
+}
+
+bool FileEnumerator::ReadDirectory(std::vector<DirectoryEntryInfo>* entries,
+                                   const FilePath& source, bool show_links) {
+
+  DIR* dir = opendir(source.value().c_str());
+  if (!dir)
+    return false;
+#ifdef OS_SOLARIS    
+  struct {
+          dirent dent_buffer;
+          char chars[MAXNAMLEN];
+  } dent_buf;
+#else  
+  struct dirent dent_buf;
+#endif  
+  struct dirent* dent;
+
+#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_FREEBSD) && \
+    !defined(OS_OPENBSD) && !defined(OS_SOLARIS)
+  #error Port warning: depending on the definition of struct dirent, \
+         additional space for pathname may be needed
+#endif
+
+  while (readdir_r(dir, (dirent *)&dent_buf, &dent) == 0 && dent) {
+    DirectoryEntryInfo info;
+    info.filename = FilePath(dent->d_name);
+
+    FilePath full_name = source.Append(dent->d_name);
+    int ret;
+    if (show_links)
+      ret = lstat(full_name.value().c_str(), &info.stat);
+    else
+      ret = stat(full_name.value().c_str(), &info.stat);
+    if (ret < 0) {
+      // Print the stat() error message unless it was ENOENT and we're
+      // following symlinks.
+      if (!(errno == ENOENT && !show_links)) {
+        LOG(ERROR) << "Couldn't stat "
+                   << source.Append(dent->d_name).value();
+      }
+      memset(&info.stat, 0, sizeof(info.stat));
+    }
+    entries->push_back(info);
   }
-  // TODO(erikkay) - verify that the other fts_info types aren't interesting
-  return Next();
-#endif
+
+  closedir(dir);
+  return true;
 }
 
 ///////////////////////////////////////////////
 // MemoryMappedFile
 
 MemoryMappedFile::MemoryMappedFile()
-    : file_(-1),
+    : file_(base::kInvalidPlatformFileValue),
       data_(NULL),
       length_(0) {
 }
 
-bool MemoryMappedFile::MapFileToMemory(const FilePath& file_name) {
-  file_ = open(file_name.value().c_str(), O_RDONLY);
-  if (file_ == -1)
+bool MemoryMappedFile::MapFileToMemoryInternal() {
+  struct stat file_stat;
+  if (fstat(file_, &file_stat) == base::kInvalidPlatformFileValue) {
+    LOG(ERROR) << "Couldn't fstat " << file_ << ", errno " << errno;
     return false;
-
-  struct stat file_stat;
-  if (fstat(file_, &file_stat) == -1)
-    return false;
+  }
   length_ = file_stat.st_size;
 
   data_ = static_cast<uint8_t*>(
-      mmap(NULL, length_, PROT_READ, MAP_SHARED, file_, 0));
+      (void*)mmap(NULL, length_, PROT_READ, MAP_SHARED, file_, 0));
   if (data_ == MAP_FAILED)
-    data_ = NULL;
-  return data_ != NULL;
+    LOG(ERROR) << "Couldn't mmap " << file_ << ", errno " << errno;
+
+  return data_ != MAP_FAILED;
 }
 
 void MemoryMappedFile::CloseHandles() {
   if (data_ != NULL)
-    munmap(data_, length_);
-  if (file_ != -1)
+    munmap((caddr_t)data_, length_);
+  if (file_ != base::kInvalidPlatformFileValue)
     close(file_);
 
   data_ = NULL;
   length_ = 0;
-  file_ = -1;
+  file_ = base::kInvalidPlatformFileValue;
+}
+
+bool HasFileBeenModifiedSince(const FileEnumerator::FindInfo& find_info,
+                              const base::Time& cutoff_time) {
+  return find_info.stat.st_mtime >= cutoff_time.ToTimeT();
+}
+
+FilePath GetHomeDir() {
+  const char* home_dir = getenv("HOME");
+  if (home_dir && home_dir[0])
+    return FilePath(home_dir);
+
+  home_dir = g_get_home_dir();
+  if (home_dir && home_dir[0])
+    return FilePath(home_dir);
+
+  FilePath rv;
+  if (file_util::GetTempDir(&rv))
+    return rv;
+
+  // Last resort.
+  return FilePath("/tmp");
 }
 
 } // namespace file_util
diff --git a/dom/plugins/ipc/PluginMessageUtils.cpp b/dom/plugins/ipc/PluginMessageUtils.cpp
--- a/dom/plugins/ipc/PluginMessageUtils.cpp
+++ b/dom/plugins/ipc/PluginMessageUtils.cpp
@@ -85,7 +85,7 @@
   }
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
 static string
 ReplaceAll(const string& haystack, const string& needle, const string& with)
 {
@@ -104,7 +104,7 @@
 string
 MungePluginDsoPath(const string& path)
 {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
   // https://bugzilla.mozilla.org/show_bug.cgi?id=519601
   return ReplaceAll(path, "netscape", "netsc@pe");
 #else
@@ -115,7 +115,7 @@
 string
 UnmungePluginDsoPath(const string& munged)
 {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_SOLARIS)
   return ReplaceAll(munged, "netsc@pe", "netscape");
 #else
   return munged;
diff --git a/ipc/chromium/Makefile.in b/ipc/chromium/Makefile.in
--- a/ipc/chromium/Makefile.in
+++ b/ipc/chromium/Makefile.in
@@ -16,7 +16,9 @@
 LIBXUL_LIBRARY = 1
 EXPORT_LIBRARY = 1
 
+ifndef SOLARIS_SUNPRO_CC
 ACDEFINES =
+endif
 
 ifndef MOZ_NATIVE_LIBEVENT # {
 vpath %.c \
@@ -118,6 +120,35 @@
   $(NULL)
 endif # }
 
+ifdef OS_SOLARIS # {
+CPPSRCS += \
+  atomicops_internals_x86_gcc.cc \
+  base_paths_linux.cc \
+  file_version_info_linux.cc \
+  idle_timer_none.cc \
+  process_util_linux.cc \
+  time_posix.cc \
+  $(NULL)
+
+ifdef MOZ_ENABLE_GTK2
+CPPSRCS += \
+  message_pump_glib.cc \
+  $(NULL)
+endif
+
+ifdef MOZ_ENABLE_QT
+MOCSRCS = \
+  moc_message_pump_qt.cc \
+  $(NULL)
+
+CPPSRCS += \
+  $(MOCSRCS) \
+  message_pump_qt.cc \
+  $(NULL)
+endif
+
+endif # } OS_SOLARIS
+
 ifdef OS_BSD # {
 ifneq (,$(OS_DRAGONFLY)$(OS_FREEBSD)) # {
 DEFINES += -D_EVENT_HAVE_SENDFILE
@@ -128,6 +159,14 @@
 
 endif # }
 
+ifdef OS_SOLARIS # {
+LOCAL_INCLUDES += -I$(srcdir)/src/third_party/libevent/solaris
+CSRCS += \
+  devpoll.c \
+  evport.c \
+  $(NULL)
+endif # }
+
 endif # }
 
 OS_CXXFLAGS += $(TK_CFLAGS)
diff --git a/mfbt/tests/TestPoisonArea.cpp b/mfbt/tests/TestPoisonArea.cpp
--- a/mfbt/tests/TestPoisonArea.cpp
+++ b/mfbt/tests/TestPoisonArea.cpp
@@ -340,7 +341,7 @@
 static bool
 ProbeRegion(uintptr_t page)
 {
-  if (madvise(reinterpret_cast<void*>(page), PAGESIZE, MADV_NORMAL)) {
+  if (posix_madvise(reinterpret_cast<char*>(page), PAGESIZE, MADV_NORMAL)) {
     return true;
   } else {
     return false;
diff --git a/ipc/chromium/src/base/basictypes.h b/ipc/chromium/src/base/basictypes.h
index dd2595c..ea2ba0c 100644
--- a/ipc/chromium/src/base/basictypes.h
+++ b/ipc/chromium/src/base/basictypes.h
@@ -37,9 +37,15 @@ const  int64_t kint64max  = (( int64_t)
 #  if defined(OS_POSIX)
 #    define __STDC_FORMAT_MACROS 1
 #    include <inttypes.h>           // for 64-bit integer format macros
+#   if defined(COMPILER_SUNPRO)
+#    define PRId64L L"I64d" 
+#    define PRIu64L L"I64u" 
+#    define PRIx64L L"I64x" 
+#   else
 #    define PRId64L "I64d"
 #    define PRIu64L "I64u"
 #    define PRIx64L "I64x"
+#   endif
 #  elif defined(OS_WIN)
 #    define PRId64 "I64d"
 #    define PRIu64 "I64u"
@@ -82,6 +88,7 @@ const  int64_t kint64max  = (( int64_t)
 // This template function declaration is used in defining arraysize.
 // Note that the function doesn't need an implementation, as we only
 // use its type.
+#if !defined(COMPILER_SUNPRO) || __SUNPRO_CC >= 0x5100
 template <typename T, size_t N>
 char (&ArraySizeHelper(T (&array)[N]))[N];
 
@@ -94,6 +101,7 @@ char (&ArraySizeHelper(const T (&array)[
 #endif
 
 #define arraysize(array) (sizeof(ArraySizeHelper(array)))
+#endif
 
 // ARRAYSIZE_UNSAFE performs essentially the same calculation as arraysize,
 // but can be used on anonymous types or types defined inside
@@ -136,6 +144,9 @@ char (&ArraySizeHelper(const T (&array)[
   ((sizeof(a) / sizeof(*(a))) / \
    static_cast<size_t>(!(sizeof(a) % sizeof(*(a)))))
 
+#if defined(COMPILER_SUNPRO) && __SUNPRO_CC < 0x5100
+#define arraysize(array) (ARRAYSIZE_UNSAFE(array))
+#endif
 
 // Use implicit_cast as a safe version of static_cast or const_cast
 // for upcasting in the type hierarchy (i.e. casting a pointer to Foo
diff --git a/ipc/chromium/src/base/icu_util.cc b/ipc/chromium/src/base/icu_util.cc
index 701dc73..1732c74 100644
--- a/ipc/chromium/src/base/icu_util.cc
+++ b/ipc/chromium/src/base/icu_util.cc
@@ -30,7 +30,7 @@
 #define ICU_UTIL_DATA_IMPL ICU_UTIL_DATA_SHARED
 #elif defined(OS_MACOSX)
 #define ICU_UTIL_DATA_IMPL ICU_UTIL_DATA_STATIC
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined (OS_SOLARIS)
 #define ICU_UTIL_DATA_IMPL ICU_UTIL_DATA_FILE
 #endif

--- a/ipc/chromium/src/base/stack_container.h
+++ b/ipc/chromium/src/base/stack_container.h
@@ -106,7 +106,7 @@ class StackAllocator : public std::alloc
       source_->used_stack_buffer_ = true;
       return source_->stack_buffer();
     } else {
-      return std::allocator<T>::allocate(n, hint);
+         return (pointer)std::allocator<T>::allocate(n, hint);
     }
   }
 
